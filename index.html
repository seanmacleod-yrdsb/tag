<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Math Tag: Park ‚Ä¢ Space ‚Ä¢ Inverted ‚Ä¢ Storm</title>
  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { background: #06130b; overflow: hidden; }

    #wrap { height: 100%; display: grid; place-items: center; }
    canvas {
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: 0 18px 60px rgba(0,0,0,.45);
      width: min(1100px, calc(100vw - 18px));
      height: auto;
      max-height: calc(100vh - 18px);
      background: #06130b;
    }

    #ui {
      position: fixed; left: 14px; top: 12px; right: 14px;
      display: none; gap: 12px; align-items: flex-start; justify-content: space-between;
      pointer-events: none; z-index: 5;
      color: rgba(255,255,255,.92);
      text-shadow: 0 2px 12px rgba(0,0,0,.55);
      font-size: 14px;
    }
    .panel {
      background: rgba(0,0,0,.30);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding: 10px 12px;
      max-width: 760px;
      line-height: 1.25;
      backdrop-filter: blur(6px);
    }
    .title { font-weight: 900; margin-bottom: 6px; letter-spacing: .2px; }
    .kbd { display: inline-block; padding: 2px 6px; border-radius: 8px; background: rgba(255,255,255,.12); border: 1px solid rgba(255,255,255,.14); margin: 0 2px; }

    .overlay {
      position: fixed; inset: 0;
      display: none;
      align-items: center; justify-content: center;
      background: rgba(0,0,0,.60);
      backdrop-filter: blur(10px);
      z-index: 20;
    }

    /* Splash */
    #splash { display: flex; }
    #sCard {
      width: min(980px, calc(100vw - 24px));
      background: radial-gradient(1200px 420px at 20% -10%, rgba(120,255,190,.20), transparent 50%),
                  radial-gradient(900px 420px at 80% 0%, rgba(120,190,255,.18), transparent 55%),
                  rgba(10,14,12,.92);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 22px;
      box-shadow: 0 24px 90px rgba(0,0,0,.58);
      padding: 18px 18px 16px;
      color: rgba(255,255,255,.95);
    }
    #brandRow { display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:12px; }
    #brand { font-size: 22px; font-weight: 1000; display:flex; align-items:center; gap:10px; letter-spacing:.3px; }
    #badge { font-size: 12px; font-weight: 900; padding:5px 10px; border-radius:999px; border:1px solid rgba(255,255,255,.14); background: rgba(255,255,255,.08); }

    .grid { display:grid; grid-template-columns: 1.05fr 1fr; gap:14px; }
    @media (max-width: 900px){ .grid{ grid-template-columns: 1fr; } }

    .box { border:1px solid rgba(255,255,255,.12); background: rgba(0,0,0,.22); border-radius:18px; padding:14px; }
    .box h3 { margin:0 0 10px; font-size: 14px; letter-spacing:.2px; opacity:.95; }
    label { font-size: 12px; font-weight: 900; opacity: .9; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }

    button {
      font-family: inherit;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.95);
      padding: 10px 12px;
      font-weight: 900;
      cursor: pointer;
    }
    .seg { display:inline-flex; gap:8px; flex-wrap:wrap; }
    .seg button.active { background: rgba(120,255,190,.16); border-color: rgba(120,255,190,.28); }

    /* Custom color dropdowns */
    .dd { position: relative; display:inline-block; min-width: 220px; }
    .ddBtn { width:100%; display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .ddLeft { display:flex; align-items:center; gap:10px; }
    .swatch { width:18px; height:18px; border-radius:6px; border:1px solid rgba(255,255,255,.28); box-shadow: 0 0 0 2px rgba(0,0,0,.28) inset; }
    .ddMenu {
      position:absolute; left:0; right:0; top: calc(100% + 8px);
      background: rgba(12,16,14,.96);
      border:1px solid rgba(255,255,255,.14);
      border-radius: 14px;
      box-shadow: 0 18px 60px rgba(0,0,0,.55);
      padding:6px;
      display:none;
      z-index: 50;
    }
    .ddItem {
      display:flex; align-items:center; gap:10px;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid transparent;
      font-weight: 900;
      cursor:pointer;
    }
    .ddItem:hover { background: rgba(255,255,255,.07); border-color: rgba(255,255,255,.10); }

    .levels { display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
    @media (max-width: 520px){ .levels{ grid-template-columns: 1fr; } }

    .levelCard {
      cursor:pointer; user-select:none;
      border-radius:18px; padding:14px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      position:relative; overflow:hidden;
    }
    .levelCard:hover { border-color: rgba(255,255,255,.22); }
    .levelCard.active { outline: 3px solid rgba(120,255,190,.28); }
    .levelTitle { font-size: 18px; font-weight: 1000; }
    .levelSub { margin-top:6px; font-size: 12px; opacity:.85; font-weight: 800; }
    .levelArt {
      position:absolute; inset:-30px -30px auto auto;
      width:220px; height:220px; border-radius:50%;
      opacity:.70;
    }
    .parkArt { background: radial-gradient(circle at 30% 30%, rgba(120,255,190,.60), transparent 55%),
                        radial-gradient(circle at 70% 60%, rgba(120,190,255,.40), transparent 60%); }
    .spaceArt { background: radial-gradient(circle at 30% 30%, rgba(170,120,255,.60), transparent 55%),
                         radial-gradient(circle at 70% 60%, rgba(120,210,255,.40), transparent 60%); }
    .invArt { background: radial-gradient(circle at 30% 30%, rgba(255,160,80,.55), transparent 55%),
                      radial-gradient(circle at 70% 60%, rgba(255,80,150,.38), transparent 60%); }

    .stormArt { background: radial-gradient(circle at 30% 30%, rgba(120,255,255,.55), transparent 55%),
                        radial-gradient(circle at 70% 60%, rgba(255,90,200,.40), transparent 60%); }

    #startRow { display:flex; justify-content:space-between; gap:12px; align-items:center; margin-top:14px; flex-wrap:wrap; }
    #startBtn {
      padding: 12px 14px; border-radius: 14px;
      border:1px solid rgba(255,255,255,.22);
      background: linear-gradient(135deg, rgba(120,255,190,.22), rgba(120,190,255,.18));
      font-weight: 1000;
      box-shadow: 0 14px 40px rgba(0,0,0,.35);
    }
    #hint { font-size: 12px; opacity: .85; font-weight: 800; line-height: 1.2; }

    .hidden { display:none !important; }

    /* Question modal */
    #qCard {
      width: min(580px, calc(100vw - 28px));
      background: rgba(10,14,12,.92);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 18px;
      box-shadow: 0 22px 70px rgba(0,0,0,.55);
      padding: 16px 16px 14px;
      color: rgba(255,255,255,.94);
    }
    #qTop { display:flex; gap:10px; align-items:center; justify-content:space-between; }
    .pill {
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.08);
      font-weight: 900;
    }
    .dot { width:10px; height:10px; border-radius:50%; }
    #qPrompt { margin:12px 0 10px; font-size: 22px; font-weight: 1000; }
    #qSub { opacity:.85; font-size: 13px; margin-bottom: 10px; }
    #qRow { display:flex; gap:10px; align-items:center; }
    #qAns {
      flex:1;
      padding:10px 12px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.95);
      font-size: 16px;
      outline: none;
    }
    #qBtn { padding:10px 12px; border-radius:12px; border:1px solid rgba(255,255,255,.20); background: rgba(90,220,120,.18); }

    /* Error overlay */
    #errOverlay { z-index: 30; }
    #errCard {
      width: min(760px, calc(100vw - 28px));
      background: rgba(14,10,10,.94);
      border: 1px solid rgba(255,255,255,.16);
      border-radius: 18px;
      box-shadow: 0 22px 70px rgba(0,0,0,.60);
      padding: 16px;
      color: rgba(255,255,255,.95);
    }
    #errTitle { font-weight: 1000; margin-bottom: 10px; }
    #errText { white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; opacity:.92; }
  
    /* Timer (top center) */
    #timerPanel{
      position: fixed;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      pointer-events: none;
      z-index: 6;
      text-align: center;
      min-width: 124px;
      height: 78px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,.28);
      border: 0;
      border-radius: 18px;
      backdrop-filter: blur(6px);
      color: rgba(255,255,255,.95);
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    #timerPanel .title{
      margin:0;
      font-size: 12px;
      font-weight: 1000;
      letter-spacing: .4px;
      opacity: .88;
    }
    #timerVal{
      font-size: 32px;
      font-weight: 1000;
      letter-spacing: .6px;
      margin-top: 4px;
      color: rgba(255,255,255,.95);
    }

    #windIcon{
      margin-top: 2px;
      font-size: 12px;
      font-weight: 1000;
      letter-spacing: .2px;
      opacity: .92;
      display:none;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
    }

</style>
</head>
<body>
  <div id="ui">
    <div class="panel" id="helpPanel">
      <div class="title">Math Tag</div>
      <div>
        P1: <span class="kbd">W</span> jump, <span class="kbd">A</span>/<span class="kbd">D</span> move ‚Ä¢
        P2: <span class="kbd">‚Üë</span> jump, <span class="kbd">‚Üê</span>/<span class="kbd">‚Üí</span> move ‚Ä¢
        Double jump always on.
      </div>
      <div style="margin-top:6px; opacity:.9;">
        Tag by colliding ‚Üí the <b>tagger</b> answers to pass ‚Äúit‚Äù. Buffs also require questions.
      </div>
    </div>
    <div class="panel" id="hudPanel">
      <div class="title">Status</div>
      <div id="hud"></div>
    </div>
  </div>

  <div class="panel" id="timerPanel">
    <div class="title">Elapsed</div>
    <div id="timerVal">0:00</div>
    <div id="windIcon">üí® Wind: ‚Üí</div>
  </div>

<div id="wrap">
    <canvas id="c" width="1100" height="650"></canvas>
  </div>

  <!-- Splash -->
  <div class="overlay" id="splash">
    <div id="sCard">
      <div id="brandRow">
        <div id="brand">üè∑Ô∏è‚ú® Math Tag <span id="badge">Park ‚Ä¢ Space ‚Ä¢ Inverted ‚Ä¢ Storm</span></div>
        <div style="opacity:.85; font-weight:1000; font-size:12px;">Single HTML</div>
      </div>

      <div class="grid">
        <div class="box">
          <h3>Players</h3>
          <div class="row" style="gap:12px;">
            <div style="display:flex; flex-direction:column; gap:6px;">
              <label>Player 1 color (WASD)</label>
              <div class="dd" id="p1DD"></div>
            </div>
            <div style="display:flex; flex-direction:column; gap:6px;">
              <label>Player 2 color (Arrows)</label>
              <div class="dd" id="p2DD"></div>
            </div>
          </div>

          <div style="margin-top:12px;">
            <h3 style="margin:0 0 10px;">Questions</h3>
            <div class="row">
              <div style="display:flex; flex-direction:column; gap:6px;">
                <label>Difficulty (Grade)</label>
                <div class="seg" id="gradeSeg"></div>
              </div>
              <div style="display:flex; flex-direction:column; gap:6px;">
                <label>Type</label>
                <div class="seg" id="typeSeg"></div>
              </div>
            </div>
          </div>

          <div style="margin-top:12px;">
            <h3 style="margin:0 0 10px;">Gameplay</h3>
            <div class="row">
              <div style="display:flex; flex-direction:column; gap:6px;">
                <label>Buffs</label>
                <div class="seg" id="buffSeg"></div>
              </div>
              <div style="display:flex; flex-direction:column; gap:6px;">
                <label>Cover objects</label>
                <div class="seg" id="coverSeg"></div>
              </div>
            </div>
          </div>

          <div style="margin-top:12px; opacity:.86; font-weight:800; font-size:12px; line-height:1.3;">
            One active effect at a time (new overrides).<br>
            Invert (harmful): correct ‚Üí enemy gets it, wrong ‚Üí you get it.
          </div>
        </div>

        <div class="box">
          <h3>Choose a Level</h3>
          <div class="levels">
            <div class="levelCard" id="lvlPark">
              <div class="levelArt parkArt"></div>
              <div class="levelTitle">üåø Park</div>
              <div class="levelSub">Green platforms ‚Ä¢ normal gravity</div>
            </div>
            <div class="levelCard" id="lvlSpace">
              <div class="levelArt spaceArt"></div>
              <div class="levelTitle">üåô Space</div>
              <div class="levelSub">Starfield ‚Ä¢ floaty gravity</div>
            </div>
            <div class="levelCard" id="lvlInv">
              <div class="levelArt invArt"></div>
              <div class="levelTitle">üôÉ Inverted</div>
              <div class="levelSub">Walk on undersides ‚Ä¢ weird gravity</div>
            </div>
            <div class="levelCard" id="lvlStorm">
              <div class="levelArt stormArt"></div>
              <div class="levelTitle">üåßÔ∏è Storm</div>
              <div class="levelSub">Neon city ‚Ä¢ wind + rain</div>
            </div>

          </div>

          <div id="startRow">
            <div id="hint">
              Launchpads = super jump. In Inverted, pads are near the <b>ceiling</b> too.<br>
              New buff in Inverted: <b>Normalize</b> (10s).
            </div>
            <button id="startBtn">Start Game</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Question Modal -->
  <div class="overlay" id="qOverlay">
    <div id="qCard">
      <div id="qTop">
        <div class="pill"><span class="dot" id="whoDot"></span><span id="whoName">P1</span> answers</div>
        <div style="opacity:.9; font-weight:1000;" id="qReason">Tag attempt</div>
      </div>
      <div id="qPrompt">Question‚Ä¶</div>
      <div id="qSub">Type your answer and press Enter. (Fractions like 3/4 are okay.)</div>
      <div id="qRow">
        <input id="qAns" autocomplete="off" inputmode="numeric" placeholder="Answer‚Ä¶" />
        <button id="qBtn">Submit</button>
      </div>
      <div id="qMsg" style="margin-top:10px; min-height:18px; font-weight:900;"></div>
      <div style="opacity:.75; font-size:12px; margin-top:8px;">Esc = skip (counts as incorrect)</div>
    </div>
  </div>

  <!-- Error overlay -->
  <div class="overlay" id="errOverlay">
    <div id="errCard">
      <div id="errTitle">‚ö†Ô∏è Something went wrong on this device</div>
      <div style="opacity:.85; font-weight:800; margin-bottom:10px;">Please copy this text to me ‚Äî I‚Äôll patch it fast.</div>
      <div id="errText"></div>
    </div>
  </div>

<script>
(() => {
  'use strict';

  // ---------------- DOM ----------------
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });

  const hudEl = document.getElementById('hud');
  const helpPanel = document.getElementById('helpPanel');
  const hudPanel = document.getElementById('hudPanel');

  const splash = document.getElementById('splash');
  const startBtn = document.getElementById('startBtn');
  const lvlPark = document.getElementById('lvlPark');
  const lvlSpace = document.getElementById('lvlSpace');
  const lvlInv = document.getElementById('lvlInv');
  const lvlStorm = document.getElementById('lvlStorm');

  const gradeSeg = document.getElementById('gradeSeg');
  const typeSeg  = document.getElementById('typeSeg');
  const buffSeg  = document.getElementById('buffSeg');
  const coverSeg = document.getElementById('coverSeg');

  const qOverlay = document.getElementById('qOverlay');
  const qPromptEl = document.getElementById('qPrompt');
  const qAnsEl = document.getElementById('qAns');
  const qBtn = document.getElementById('qBtn');
  const qMsgEl = document.getElementById('qMsg');
  const whoDot = document.getElementById('whoDot');
  const whoName = document.getElementById('whoName');
  const qReasonEl = document.getElementById('qReason');

  const errOverlay = document.getElementById('errOverlay');
  const errTextEl = document.getElementById('errText');

  const timerValEl = document.getElementById('timerVal');
  const windIconEl = document.getElementById('windIcon');
  const timerPanelEl = document.getElementById('timerPanel');

  // ---------------- Constants ----------------
  const BASE_W = 1100, BASE_H = 650;
  const W = BASE_W, H = BASE_H;

  const COLORS = [
    { name: "Blue",   hex: "#39a9ff" },
    { name: "Red",    hex: "#ff4b4b" },
    { name: "Green",  hex: "#3cff7b" },
    { name: "Yellow", hex: "#ffe36a" },
    { name: "Orange", hex: "#ff9a3c" },
    { name: "Purple", hex: "#b184ff" },
    { name: "Pink",   hex: "#ff6ad5" },
    { name: "Cyan",   hex: "#49fff2" },
  ];

  const GRADES = ["Grade 4", "Grade 5", "Grade 6"];
  const QTYPES = ["Numbers", "Geometry", "Operations"];

  // ---------------- Utils ----------------
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const rand = (a,b)=>a+Math.random()*(b-a);
  const randi = (a,b)=>Math.floor(rand(a,b));
  const nowMs = ()=>performance.now();


  function formatTime(ms){
    const total = Math.max(0, Math.floor(ms/1000));
    const m = Math.floor(total/60);
    const s = total % 60;
    return `${m}:${String(s).padStart(2,'0')}`;
  }


  function aabb(a,b){
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  function showSplash(show){
    splash.style.display = show ? 'flex' : 'none';
  }

  function showFatal(err){
    errOverlay.style.display = 'flex';
    errTextEl.textContent = String(err && err.stack ? err.stack : err);
  }

  // HiDPI
  function applyHiDPI(){
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    canvas.width = Math.floor(BASE_W * dpr);
    canvas.height = Math.floor(BASE_H * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  applyHiDPI();
  window.addEventListener('resize', applyHiDPI);

  // ---------------- Input ----------------
  const keys = new Set();
  window.addEventListener('keydown', (e) => {
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) e.preventDefault();
    if (game.state === 'question') return;
    keys.add(e.key);
  }, { passive:false });
  window.addEventListener('keyup', (e) => keys.delete(e.key));

  // ---------------- Custom UI bits ----------------
  function buildSeg(container, items, onPick, defaultIndex=0) {
    container.innerHTML = "";
    items.forEach((label, idx) => {
      const b = document.createElement('button');
      b.textContent = label;
      b.addEventListener('click', () => {
        [...container.querySelectorAll('button')].forEach(x=>x.classList.remove('active'));
        b.classList.add('active');
        onPick(label, idx);
      });
      container.appendChild(b);
    });
    container.querySelectorAll('button')[defaultIndex].classList.add('active');
    onPick(items[defaultIndex], defaultIndex);
  }

  function makeColorDropdown(mountEl, defaultName) {
    const dd = document.createElement('div');
    dd.className = 'dd';

    const btn = document.createElement('button');
    btn.className = 'ddBtn';
    btn.type = 'button';

    const left = document.createElement('span');
    left.className = 'ddLeft';

    const sw = document.createElement('span');
    sw.className = 'swatch';

    const txt = document.createElement('span');
    txt.style.fontWeight = '1000';

    const chev = document.createElement('span');
    chev.textContent = '‚ñæ';
    chev.style.opacity = '0.85';
    chev.style.fontWeight = '1000';

    left.appendChild(sw);
    left.appendChild(txt);
    btn.appendChild(left);
    btn.appendChild(chev);

    const menu = document.createElement('div');
    menu.className = 'ddMenu';

    dd.appendChild(btn);
    dd.appendChild(menu);
    mountEl.replaceWith(dd);

    let value = COLORS.find(c => c.name === defaultName)?.hex || COLORS[0].hex;

    function setVal(hex){
      value = hex || COLORS[0].hex;
      const item = COLORS.find(c => c.hex === value) || COLORS[0];
      sw.style.background = item.hex;
      txt.textContent = item.name;
    }

    function closeMenu(){ menu.style.display = 'none'; }
    function toggleMenu(){ menu.style.display = (menu.style.display === 'block') ? 'none' : 'block'; }

    COLORS.forEach(c => {
      const it = document.createElement('div');
      it.className = 'ddItem';
      const s = document.createElement('span');
      s.className = 'swatch';
      s.style.background = c.hex;
      const t = document.createElement('span');
      t.textContent = c.name;
      it.appendChild(s); it.appendChild(t);
      it.addEventListener('click', () => { setVal(c.hex); closeMenu(); dd.dispatchEvent(new Event('change')); });
      menu.appendChild(it);
    });

    btn.addEventListener('click', (e) => { e.stopPropagation(); toggleMenu(); });
    window.addEventListener('click', closeMenu);

    setVal(value);

    return {
      get value(){ return value; },
      set value(hex){ setVal(hex); },
      onChange(fn){ dd.addEventListener('change', fn); }
    };
  }

  // ---------------- Levels ----------------
  function makeLevelPark(){
    const groundH = 48;
    const ground = { x: 0, y: H-groundH, w: W, h: groundH, kind:'ground' };
    const pads = [
      { x: 14, y: H-groundH-14, w: 80, h: 14, dir: 'up' },
      { x: W-14-80, y: H-groundH-14, w: 80, h: 14, dir: 'up' },
    ];
    const platforms = [
      ground,
      { x: 0, y: H-360, w: 220, h: 16 },
      { x: W-220, y: H-360, w: 220, h: 16 },
      { x: 160, y: H-170, w: 220, h: 20 },
      { x: W-160-220, y: H-170, w: 220, h: 20 },
      { x: (W/2)-170, y: H-270, w: 340, h: 22, kind:'ice' },
      { x: 170, y: H-360, w: 210, h: 20 },
      { x: W-170-210, y: H-360, w: 210, h: 20 },
      { x: (W/2)-120, y: H-450, w: 240, h: 18 },
      { x: (W/2)-420, y: H-430, w: 120, h: 16 },
      { x: (W/2)+300, y: H-430, w: 120, h: 16 },
    ];
    return {
      name: "Park",
      theme: "park",
      gravity: 1400,
      maxFall: 950,
      baseJump: 520,
      baseSpeed: 250,
      horizInvert: false,
      groundH,
      pads,
      platforms,
      
obstacles: [
  // Ground cover
  { x: 110, y: H-groundH-80,  w: 120, h: 80,  type:'bush' },
  { x: W*0.28, y: H-groundH-95, w: 140, h: 95, type:'bush' },

  { x: W*0.18, y: H-groundH-140, w: 60,  h: 140, type:'tree' },
  { x: W*0.82, y: H-groundH-150, w: 62,  h: 150, type:'tree' },

  // Epic big tree: spans most of the canvas
  { x: W*0.52-130, y: H-groundH-600, w: 260, h: 600, type:'bigTree', noClamp:true },

  // Platform cover (non-solid, just visual occlusion)
  // Left lower platform (y: H-170)
  { x: 210, y: (H-170)-120, w: 96, h: 120, type:'bench' },
  // Right lower platform (y: H-170)
  { x: W-210-96, y: (H-170)-120, w: 96, h: 120, type:'bench' },
  // Mid large platform (y: H-270)
  { x: (W/2)-40, y: (H-270)-92, w: 80, h: 92, type:'rock' },
  // Higher mid platform (y: H-450)
  { x: (W/2)-10, y: (H-450)-104, w: 74, h: 104, type:'bush' },

  { x: W*0.70, y: H-groundH-78,  w: 115, h: 78, type:'bush' },
  { x: W*0.06, y: H-groundH-125, w: 56,  h: 125, type:'tree' },
],
buffIcons: {
        speed: '‚ö°', jump: 'ü¶ò', both: '‚ú®',
        swapIt: 'üëë', invert: 'üîÅ', teleport: 'üåÄ', slowEnemy: 'üßä', invis: 'üëª'
      }
    };
  }

  function makeLevelSpace(){
    const groundH = 44;
    const ground = { x: 0, y: H-groundH, w: W, h: groundH, kind:'ground' };
    const pads = [
      { x: 14, y: H-groundH-14, w: 80, h: 14, dir:'up' },
      { x: W-14-80, y: H-groundH-14, w: 80, h: 14, dir:'up' },
    ];
    const platforms = [
      ground,
      { x: 0, y: H-360, w: 220, h: 14 },
      { x: W-220, y: H-360, w: 220, h: 14 },
      { x: (W/2)-320, y: H-190, w: 260, h: 18 },
      { x: (W/2)+60,  y: H-190, w: 260, h: 18 },
      { x: (W/2)-140, y: H-285, w: 280, h: 18, kind:'ice' },
      { x: 220, y: H-360, w: 180, h: 16 },
      { x: W-220-180, y: H-360, w: 180, h: 16 },
      { x: (W/2)-380, y: H-440, w: 200, h: 16 },
      { x: (W/2)+180, y: H-440, w: 200, h: 16 },
      { x: (W/2)-130, y: H-525, w: 260, h: 16 },
      { x: 120, y: H-520, w: 150, h: 14 },
      { x: W-270, y: H-520, w: 150, h: 14 },
    ];
    return {
      name: "Space",
      theme: "space",
      gravity: 820,
      maxFall: 620,
      baseJump: 480,
      baseSpeed: 240,
      horizInvert: false,
      groundH,
      pads,
      platforms,
      
obstacles: [
  // Ground-ish cover
  { x: W*0.10, y: H-groundH-140, w: 72,  h: 140, type:'crate' },
  { x: W*0.34, y: H-groundH-95,  w: 120, h: 95,  type:'asteroid' },
  { x: W*0.62, y: H-groundH-160, w: 86,  h: 160, type:'crate' },
  { x: W*0.82, y: H-groundH-110, w: 110, h: 110, type:'asteroid' },

  // Platform cover (aligned to platform tops)
  // Left low platform (y: H-190)
  { x: (W/2)-250, y: (H-190)-70, w: 70, h: 70, type:'asteroid' },
  // Right low platform (y: H-190)
  { x: (W/2)+180, y: (H-190)-86, w: 72, h: 86, type:'crate' },

  // Mid platform (y: H-285)
  { x: W-220, y: 60, w: 180, h: 180, type:'planet', noClamp:true },

  // Higher platforms
  { x: 250, y: (H-360)-86, w: 72, h: 86, type:'crate' },
  { x: W-250-120, y: (H-360)-70, w: 110, h: 70, type:'asteroid' },

  // Tall "tower" cover (still good for ground hide)
  { x: W*0.46, y: H-groundH-260, w: 64,  h: 260, type:'crate' },
],
buffIcons: {
        speed: 'üöÄ', jump: 'üåô', both: '‚ú®',
        swapIt: 'üëΩ', invert: 'üåÄ', teleport: 'üõ∏', slowEnemy: 'üßä', invis: 'üëª'
      }
    };
  }

  function makeLevelInverted(){
    // Inverted world: gravity pulls upward. Players ‚Äústick‚Äù to undersides.
    const topH = 20;
    const bottomH = 48;
    const groundH = bottomH;

    const ceiling = { x: 0, y: 0, w: W, h: topH, kind:'ceiling' };
    const floor   = { x: 0, y: H-bottomH, w: W, h: bottomH, kind:'ground' };

    // Put most platforms near the top so you can hang underneath them.
    const platforms = [

ceiling,
floor,

// Top layer (main hang points)
{ x: 130, y: 90,  w: 260, h: 18 },
{ x: W-130-260, y: 90, w: 260, h: 18 },

// Wide central anchor
{ x: (W/2)-260, y: 180, w: 520, h: 20, kind:'ice' },

// Mid layer (staggered for easier chaining)
{ x: 170, y: 270, w: 230, h: 16 },            // left: a bit higher
{ x: W-170-230, y: 310, w: 230, h: 16 },      // right: a bit lower

// Center connectors (small steps to bridge the gap)
{ x: (W/2)-260, y: 340, w: 160, h: 14 },
{ x: (W/2)+100, y: 340, w: 160, h: 14 },

// LOWER platforms (toward bottom = ‚Äúhigher‚Äù feeling) ‚Äî staggered
{ x: (W/2)-360, y: 420, w: 210, h: 14 },      // left: lower
{ x: (W/2)+150, y: 390, w: 210, h: 14 },      // right: higher

// Side-connected lower corner routes (attach to walls)
{ x: 0,     y: 520, w: 240, h: 14 },
{ x: W-240, y: 520, w: 240, h: 14 },
];

    // Launchpads: provide top pads (push ‚Äúdown‚Äù), and also bottom pads for when Normalize is active.
    const pads = [
      // top pads (for inverted play)
      { x: 14, y: topH+8, w: 80, h: 14, dir:'down' },
      { x: W-14-80, y: topH+8, w: 80, h: 14, dir:'down' },
      // bottom pads (for temporary normalized play)
      { x: 14, y: H-bottomH-14, w: 80, h: 14, dir:'up' },
      { x: W-14-80, y: H-bottomH-14, w: 80, h: 14, dir:'up' },
    ];

    return {
      name: "Inverted",
      theme: "inverted",
      gravity: -1200,          // upward pull
      maxFall: 900,            // speed cap (magnitude)
      baseJump: 520,           // jump magnitude; direction determined by gravity sign
      baseSpeed: 245,
      horizInvert: true,       // left/right reversed in this level
      groundH: bottomH,
      topH,
      pads,
      platforms,
      
obstacles: [
  // In Inverted, players hang under platforms.
  // We align cover to the *bottom* of platforms (platform.y + platform.h) and extend downward.
  // Kept intentionally LIGHT to reduce clutter.

  // Under left top platform (y:90,h:18 ‚Üí bottom 108)
  { x: 170, y: 108, w: 84, h: 220, type:'pillar' },

  // Under central anchor (y:180,h:20 ‚Üí bottom 200)
  { x: (W/2)-36, y: 200, w: 140, h: 86, type:'pillar' },

  // Under right top platform
  { x: W-170-84, y: 108, w: 84, h: 240, type:'pillar' },

  // Two lower pillars for endgame hideouts
  { x: (W/2)-330, y: 434, w: 64, h: 150, type:'pillar' }, // left lower (420+14)
  { x: (W/2)+280, y: 404, w: 64, h: 150, type:'pillar' }, // right higher (390+14)
],
buffIcons: {
        speed:'‚ö°', jump:'ü¶á', both:'‚ú®',
        swapIt:'üëë', invert:'üîÅ', teleport:'üåÄ', slowEnemy:'üßä',
        normalize:'üß≠',
        invis:'üëª'
      }
    };
  }

  
  function makeLevelStorm(){
    const groundH = 46;
    const ground = { x: 0, y: H-groundH, w: W, h: groundH, kind:'ground' };
    const pads = [
      { x: 14, y: H-groundH-14, w: 80, h: 14, dir:'up' },
      { x: W-14-80, y: H-groundH-14, w: 80, h: 14, dir:'up' },
    ];

    const platforms = [
      ground,
      { x: 0, y: H-340, w: 220, h: 14 },
      { x: W-220, y: H-340, w: 220, h: 14 },
      { x: 140, y: H-170, w: 240, h: 18 },
      { x: W-140-240, y: H-170, w: 240, h: 18 },
      // Slick ‚Äúwet‚Äù rooftop catwalk
      { x: (W/2)-220, y: H-245, w: 440, h: 18, kind:'ice' },

      { x: 190, y: H-340, w: 200, h: 16 },
      { x: W-190-200, y: H-340, w: 200, h: 16 },

      { x: (W/2)-360, y: H-430, w: 220, h: 16 },
      { x: (W/2)+140, y: H-430, w: 220, h: 16 },

      { x: (W/2)-120, y: H-520, w: 240, h: 14 },
    ];

    return {
      name: "Storm",
      theme: "storm",
      gravity: 1350,
      maxFall: 940,
      baseJump: 520,
      baseSpeed: 252,
      horizInvert: false,
      groundH,
      pads,
      platforms,
      obstacles: [
        // All cover objects: clamp later to player height, so these are ‚Äúsuggested‚Äù sizes.
        { x: W*0.12, y: H-groundH-120, w: 120, h: 120, type:'neonSign' },
        { x: W*0.80, y: H-groundH-110, w: 110, h: 110, type:'neonSign' },
        { x: (W/2)-44, y: (H-170)-92, w: 96, h: 92, type:'vent' },
        { x: (W/2)+260, y: (H-430)-92, w: 92, h: 92, type:'vent' },
      ],
      buffIcons: {
        speed:'‚ö°', jump:'ü¶ò', both:'‚ú®',
        swapIt:'üëë', invert:'üîÅ', teleport:'üåÄ', slowEnemy:'üßä', invis:'üëª'
      }
    };
  }


  function clampCoverObjects(level){
  if (!level || !Array.isArray(level.obstacles)) return level;
  const maxH = 46; // character height (most cover)
  const inv = (level.theme === 'inverted');

  // Some special ‚Äúhero‚Äù cover pieces are allowed to be larger:
  // - Park: bigTree
  // - Space: planet
  level.obstacles = level.obstacles.map(o=>{
    if (!o) return o;
    if (o.noClamp || o.type === 'bigTree' || o.type === 'planet') return o;

    const oh = Math.max(6, Number(o.h||0));
    const nh = Math.min(maxH, oh);
    const dy = inv ? 0 : (oh - nh); // keep bottoms aligned (normal levels)
    return { ...o, h: nh, y: (o.y||0) + dy };
  });

  return level;
}

  // ---------------- Game State ----------------
  const game = {
    state: 'splash', // splash | play | question
    level: clampCoverObjects(makeLevelPark()),
    config: { p1Color: "#39a9ff", p2Color: "#ff4b4b", grade:"Grade 5", qtype:"Numbers" },
    options: { enableBuffs:true, enableCover:true },
    buffsOnMap: [],
    buffSpawnTimer: 0,
    lastOverlap: false,
    lastT: nowMs(),
    globalEffect: { kind:null, until:0 }, // e.g., normalizeWorld (Inverted only)
    tagLatch: false,
    startTimeMs: 0,
    headstartUntil: 0,
    headstartItId: '',
    wind: { dir: 0, v: 0, targetV: 0, nextChange: 0, gustUntil: 0 }
  };

  function globalActive(kind){
    return game.globalEffect.kind === kind && nowMs() < game.globalEffect.until;
  }
  function setGlobal(kind, ms){
    game.globalEffect.kind = kind;
    game.globalEffect.until = nowMs() + ms;
  }
  function clearGlobal(){
    game.globalEffect.kind = null;
    game.globalEffect.until = 0;
  }

  // ---------------- Splash wiring ----------------
  let pickedGrade = "Grade 5";
  let pickedType = "Numbers";
  buildSeg(gradeSeg, GRADES, (x)=>pickedGrade=x, 1);
  buildSeg(typeSeg, QTYPES, (x)=>pickedType=x, 0);

  let buffsEnabled = true;
  let coverEnabled = true;
  buildSeg(buffSeg, ['On','Off'], (x)=>buffsEnabled = (x==='On'), 0);
  buildSeg(coverSeg,['On','Off'], (x)=>coverEnabled = (x==='On'), 0);

  let selectedLevel = "Park";
  function setLevelChoice(name){
    selectedLevel = name;
    lvlPark.classList.toggle('active', name === "Park");
    lvlSpace.classList.toggle('active', name === "Space");
    lvlInv.classList.toggle('active', name === "Inverted");
    lvlStorm.classList.toggle('active', name === "Storm");
  }
  lvlPark.addEventListener('click', ()=>setLevelChoice("Park"));
  lvlSpace.addEventListener('click', ()=>setLevelChoice("Space"));
  lvlInv.addEventListener('click', ()=>setLevelChoice("Inverted"));
  lvlStorm.addEventListener('click', ()=>setLevelChoice("Storm"));
  setLevelChoice("Park");

  // Double-click a level card to start immediately (Start button still works)
  lvlPark.addEventListener('dblclick', () => { setLevelChoice("Park"); startBtn.click(); });
  lvlSpace.addEventListener('dblclick', () => { setLevelChoice("Space"); startBtn.click(); });
  lvlInv.addEventListener('dblclick', () => { setLevelChoice("Inverted"); startBtn.click(); });
  lvlStorm.addEventListener('dblclick', () => { setLevelChoice("Storm"); startBtn.click(); });


  const p1DD = makeColorDropdown(document.getElementById('p1DD'), "Blue");
  const p2DD = makeColorDropdown(document.getElementById('p2DD'), "Red");

  function enforceDifferentColors(){
    if (p1DD.value === p2DD.value) {
      const idx = COLORS.findIndex(c=>c.hex===p2DD.value);
      p2DD.value = COLORS[(idx+1) % COLORS.length].hex;
    }
  }
  p1DD.onChange(enforceDifferentColors);
  p2DD.onChange(enforceDifferentColors);
  enforceDifferentColors();

  startBtn.addEventListener('click', () => {
    game.config = { p1Color: p1DD.value, p2Color: p2DD.value, grade: pickedGrade, qtype: pickedType };
    if (selectedLevel === "Space") game.level = makeLevelSpace();
    else if (selectedLevel === "Inverted") game.level = makeLevelInverted();
    else if (selectedLevel === "Storm") game.level = makeLevelStorm();
    else game.level = makeLevelPark();

    clampCoverObjects(game.level);
    resetPlayers(true);
    startGame();
  });

  // ---------------- Players ----------------
  function makePlayer(id, color, x, y, controls){
    return {
      id,
      color: (typeof color === 'string' && color.trim()) ? color : '#ffffff',
      x, y, w: 34, h: 46,
      vx: 0, vy: 0,
      facing: 1,
      onGround: false,
      jumpsLeft: 2,
      isIt: false,
      controls,
      tagCooldown: 0,
      effect: { kind: null, until: 0 },
      _jumpHeld: false,
      _launchCD: 0,
      _onPlat: null,
      _onIce: false
    };
  }

  let P1 = null, P2 = null;

  function resetPlayers(initOnly=false){
    const c1 = game.config.p1Color || "#39a9ff";
    const c2 = game.config.p2Color || "#ff4b4b";

    // Spawn positions depend on level:
    if (game.level.theme === 'inverted') {
      // start near top so they can ‚Äústick‚Äù quickly
      P1 = makePlayer('P1', c1, 220, 240, { left:'a', right:'d', jump:'w' });
      P2 = makePlayer('P2', c2, W-260, 240, { left:'ArrowLeft', right:'ArrowRight', jump:'ArrowUp' });
    } else {
      P1 = makePlayer('P1', c1, 220, H-260, { left:'a', right:'d', jump:'w' });
      P2 = makePlayer('P2', c2, W-260, H-260, { left:'ArrowLeft', right:'ArrowRight', jump:'ArrowUp' });
    }

    if (!initOnly) (Math.random() < 0.5 ? P1 : P2).isIt = true;
  }

  // ---------------- Physics helpers ----------------
  function resolveAABB(m, s, gravitySign){
    // gravitySign: +1 for normal (down), -1 for inverted (up)
    const dx1 = (s.x + s.w) - m.x;
    const dx2 = (m.x + m.w) - s.x;
    const dy1 = (s.y + s.h) - m.y;
    const dy2 = (m.y + m.h) - s.y;
    const ox = Math.min(dx1, dx2);
    const oy = Math.min(dy1, dy2);

    if (ox < oy) {
      if (dx1 < dx2) m.x = s.x + s.w;
      else m.x = s.x - m.w;
      m.vx = 0;
    } else {
      // Vertical resolution
      if (dy1 < dy2) {
        // push DOWN: m.y = s.y + s.h
        m.y = s.y + s.h;
        // If gravity pulls UP, landing is on underside (ceiling-walk)
        if (gravitySign < 0 && m.vy < 0) {
          m.vy = 0;
          m.onGround = true;
          m.jumpsLeft = 2;
          m._onPlat = s;
          m._onPlat = s;
        } else {
          if (m.vy < 0) m.vy = 0;
        }
      } else {
        // push UP: m.y = s.y - m.h
        m.y = s.y - m.h;
        // If gravity pulls DOWN, this is normal landing
        if (gravitySign > 0 && m.vy > 0) {
          m.vy = 0;
          m.onGround = true;
          m.jumpsLeft = 2;
          m._onPlat = s;
        } else {
          if (m.vy > 0) m.vy = 0;
        }
      }
    }
  }

  function effectActive(p){ return p && p.effect && p.effect.kind && nowMs() < p.effect.until; }
  function effectKind(p){ return effectActive(p) ? p.effect.kind : null; }
  function clearEffect(p){ if (!p) return; p.effect.kind=null; p.effect.until=0; }
  function setEffect(p, kind, ms){ if (!p) return; p.effect.kind=kind; p.effect.until=nowMs()+ms; }

  function worldIsNormalized(){
    // Only meaningful in inverted level
    return game.level.theme === 'inverted' && globalActive('normalizeWorld');
  }

  function gravityValue(){
    if (worldIsNormalized()) return 1400;
    return game.level.gravity;
  }
  function gravitySign(){
    return Math.sign(gravityValue() || 1);
  }
  function baseSpeed(){
    return worldIsNormalized() ? 250 : game.level.baseSpeed;
  }
  function baseJump(){
    return worldIsNormalized() ? 520 : game.level.baseJump;
  }
  function horizInvertedByLevel(){
    return (!worldIsNormalized() && !!game.level.horizInvert);
  }

  function speedFor(p){
    let s = baseSpeed();
    const k = effectKind(p);
    if (k === 'speed' || k === 'both') s *= 1.65;
    if (k === 'slow') s *= 0.60;
    return s;
  }
  function jumpFor(p){
    let j = baseJump();
    const k = effectKind(p);
    if (k === 'jump' || k === 'both') j *= 1.25;
    return j;
  }
  function invertedControlsDebuff(p){
    return effectKind(p) === 'invert';
  }

  function updatePlayer(p, dt){
    if (!p) return;

    p.onGround = false;
    p._onPlat = null;
    p.tagCooldown = Math.max(0, p.tagCooldown - dt);
    p._launchCD = Math.max(0, p._launchCD - dt);


    const frozenByHeadstart = (game.headstartUntil && nowMs() < game.headstartUntil && p.id === game.headstartItId);

    const invDebuff = invertedControlsDebuff(p) ? -1 : 1;
    const invLevel = horizInvertedByLevel() ? -1 : 1;

    const left = !frozenByHeadstart && keys.has(p.controls.left);
    const right = !frozenByHeadstart && keys.has(p.controls.right);
    const jump = !frozenByHeadstart && keys.has(p.controls.jump);

    let move = 0;
    if (left) move -= 1;
    if (right) move += 1;
    move *= invDebuff * invLevel;

    // Horizontal movement + ice physics
    // NOTE: p._onIce reflects LAST frame; we update it after collisions below.
    const onIcePrev = !!p._onIce;

    // On ice: a bit faster top speed, and MUCH more momentum (slow decel).
    const speed = speedFor(p) * (onIcePrev ? 1.45 : 1.0);
    const targetVx = move * speed;

    // Faster acceleration so ice doesn't feel sluggish, but very low decel when you stop.
    const accel = onIcePrev ? 3000 : 2200;
    const decel = onIcePrev ? 220 : 2600;
    const a = (move === 0) ? decel : accel;

    p.vx += clamp(targetVx - p.vx, -a*(dt/1000), a*(dt/1000));

    // Extra glide: when you're not pressing anything on ice, keep coasting.
    if (onIcePrev && move === 0) {
      const keep = Math.pow(0.985, dt/16.67); // ~1.5% loss per frame @60fps
      p.vx *= keep;
    }

    if (frozenByHeadstart) { p.vx *= 0.80; }
    if (move !== 0) p.facing = Math.sign(move);

    // Jump direction depends on gravity:
    // gravitySign > 0 (normal): jump sets vy negative (up)
    // gravitySign < 0 (inverted): jump sets vy positive (down)
    const gSign = gravitySign();
    if (!p._jumpHeld && jump) {
      if (p.jumpsLeft > 0) {
        p.vy = (-gSign) * jumpFor(p);
        p.jumpsLeft -= 1;
      }
    }
    p._jumpHeld = jump;

    // gravity
    const gVal = gravityValue();
    p.vy += gVal * (dt/1000);

    // cap fall speed by magnitude + direction
    const maxV = (worldIsNormalized() && game.level.theme === 'inverted') ? 950 : game.level.maxFall;
    if (gVal > 0) p.vy = Math.min(p.vy, maxV);
    else p.vy = Math.max(p.vy, -maxV);

    // integrate
    p.x += p.vx * (dt/1000);
    p.y += p.vy * (dt/1000);

    // horizontal wrap-around
    if (p.x < -p.w) p.x = W;
    else if (p.x > W) p.x = -p.w;

    // collide platforms
    const gravS = gSign;
    for (const plat of (game.level.platforms)) {
      if (aabb(p, plat)) resolveAABB(p, plat, gravS);
    }

    p._onIce = !!(p.onGround && p._onPlat && p._onPlat.kind === 'ice');

// Storm wind: apply as a real physics force so it's unmistakable.
    // We do this AFTER platform collisions (so you still "stick" to surfaces),
    // but BEFORE safety clamps / launchpads.
    if (game.level.theme === 'storm' && game.wind) {
      const dir = game.wind.dir || 0;
      const v = game.wind.v || 0; // px/s (signed later)
      // Treat v as a wind *velocity* and blend it into player motion.
      // Stronger in air; still noticeable on ground.
      const windVelRaw = dir * v * (p.onGround ? 0.55 : 1.15);
// cap so gusts feel strong but fair
const windVel = clamp(windVelRaw, -260, 260);

// Add a gentle drift so it's always felt.
p.x += windVel * (dt/1000) * 0.55;

// Bias vx toward wind to create "carried" feeling (stronger in air).
const follow = p.onGround ? 0.08 : 0.12;
p.vx += (windVel - p.vx) * follow;
    }


    // safety clamps (keep in map)
    if (p.y < -20) { p.y = -20; p.vy = 0; }
    if (p.y > H - p.h + 20) { p.y = H - p.h + 20; p.vy = 0; }

    // launch pads
    for (const lp of game.level.pads) {
      if (aabb(p, lp) && p._launchCD <= 0) {
        // dir: up => strong negative vy; down => strong positive vy
        const strength = (game.level.theme === 'space') ? 740 : 820;
        p.vy = (lp.dir === 'up') ? -strength : +strength;
        p._launchCD = 700;
      }
    }

    // expire local effect
    if (p.effect.kind && nowMs() >= p.effect.until) clearEffect(p);
  }

  // ---------------- Questions (simplified & quick) ----------------
  let pendingQuestion = null;

  function normalizeAnswer(s){ return (s ?? '').toString().trim().replace(/\s+/g,''); }
  function parseMaybeNumberOrFraction(s){
    s = normalizeAnswer(s);
    if (!s) return null;
    if (s.includes('/')) {
      const [a,b] = s.split('/');
      const na = Number(a), nb = Number(b);
      if (!Number.isFinite(na) || !Number.isFinite(nb) || nb === 0) return null;
      return na/nb;
    }
    const n = Number(s);
    return Number.isFinite(n) ? n : null;
  }

  function gradeParams(g){
    // Keep it quick: small numbers, but slightly more range by grade.
    if (g === "Grade 4") return { addMax: 40, subMax: 60, mulMax: 8, divMax: 8 };
    if (g === "Grade 6") return { addMax: 120, subMax: 140, mulMax: 10, divMax: 10 };
    return { addMax: 80, subMax: 100, mulMax: 9, divMax: 9 };
  }

  function makeQuestion(grade, type){
    const gp = gradeParams(grade);
    const simple = (text, ans)=>({ text, check:(s)=>parseMaybeNumberOrFraction(s) === ans });
    const Q = [];

    if (type === "Numbers") {
      Q.push(()=>{ const a=randi(2,gp.addMax), b=randi(2,gp.addMax); return simple(`${a} + ${b} = ?`, a+b); });
      Q.push(()=>{ const a=randi(10,gp.subMax), b=randi(2, Math.min(30,a-1)); return simple(`${a} ‚àí ${b} = ?`, a-b); });
      Q.push(()=>{ const a=randi(2,30), b=randi(2,30); return simple(`${a} + ${b} ‚àí 10 = ?`, a+b-10); });
      Q.push(()=>{ const a=randi(10,99); return simple(`What is ${a} rounded to the nearest 10?`, Math.round(a/10)*10); });
    }

    if (type === "Geometry") {
      Q.push(()=>{ const w=randi(2,12), h=randi(2,12); return simple(`Area of ${w}√ó${h}?`, w*h); });
      Q.push(()=>{ const w=randi(3,15), h=randi(3,15); return simple(`Perimeter of ${w}√ó${h}?`, 2*(w+h)); });
      Q.push(()=>{ const a=randi(20,160); return simple(`Straight line: 180 ‚àí ${a} = ?`, 180-a); });
      Q.push(()=>{ const a=randi(30,100), b=randi(30,100); return simple(`Triangle: 180 ‚àí (${a}+${b}) = ?`, 180-(a+b)); });
    }

    if (type === "Operations") {
      // Brackets-based, short, and small multiplication/division (<=10x10, <=100)
      Q.push(()=>{ const a=randi(1,12), b=randi(1,12), c=randi(1,12); return simple(`(${a} + ${b}) ‚àí ${c} = ?`, (a+b)-c); });
      Q.push(()=>{ const a=randi(1,12), b=randi(1,12), c=randi(1,12); return simple(`${a} + (${b} ‚àí ${c}) = ?`, a+(b-c)); });
      Q.push(()=>{ const a=randi(2,gp.mulMax), b=randi(2,gp.mulMax), c=randi(1,15); return simple(`(${a} √ó ${b}) + ${c} = ?`, (a*b)+c); });
      Q.push(()=> {
        const d=randi(2,gp.divMax);
        const ans=randi(2,10);
        const n=d*ans; // <= 100 guaranteed because d<=10, ans<=10
        return simple(`${n} √∑ ${d} = ?`, ans);
      });
    }

    return (Q.length ? Q[randi(0,Q.length)]() : simple("9 + 7 = ?", 16));
  }

  function showQuestion({ who, reason, q }){
    game.state = 'question';
    qOverlay.style.display = 'flex';
    qMsgEl.textContent = '';
    pendingQuestion = { who, reason, q };

    qPromptEl.textContent = q.text;
    qReasonEl.textContent = reason;
    whoName.textContent = who.id;
    whoDot.style.background = who.color;

    qAnsEl.value = '';
    qAnsEl.focus();
  }

  function closeQuestion(){
    qOverlay.style.display = 'none';
    game.state = 'play';
    pendingQuestion = null;
  }

  function submitAnswer(force=null){
    if (!pendingQuestion) return;
    const ok = (force !== null) ? force : pendingQuestion.q.check(qAnsEl.value);

    qMsgEl.textContent = ok ? "‚úÖ Correct!" : "‚ùå Not quite.";
    qMsgEl.style.color = ok ? "rgba(140,255,170,.95)" : "rgba(255,160,160,.95)";

    setTimeout(() => {
      const onResolve = pendingQuestion.q.onResolve;
      closeQuestion();
      if (typeof onResolve === 'function') onResolve(ok);
    }, 420);
  }

  qBtn.addEventListener('click', ()=>submitAnswer());
  qAnsEl.addEventListener('keydown', (e)=>{
    if (e.key === 'Enter') submitAnswer();
    if (e.key === 'Escape') submitAnswer(false);
  });

  // ---------------- Buffs ----------------
  const BUFFS_BASE = [
    { key:'invis',     label:'Invisibility (5s)',     rarity:0.70, duration:5000,  kind:'invis',  positive:true },
    { key:'speed',     label:'Superspeed (10s)',      rarity:1.00, duration:10000, kind:'speed',  positive:true },
    { key:'jump',      label:'Higher Jumps (10s)',    rarity:1.00, duration:10000, kind:'jump',   positive:true },
    { key:'both',      label:'Jump + Speed (10s)',    rarity:0.45, duration:10000, kind:'both',   positive:true },
    { key:'swapIt',    label:'Make other ‚Äúit‚Äù',       rarity:0.12, duration:0,     kind:null,     positive:true },
    { key:'invert',    label:'Invert Controls (10s)', rarity:0.55, duration:10000, kind:'invert', positive:false, harmful:true },
    { key:'teleport',  label:'Teleporter',           rarity:0.70, duration:0,     kind:null,     positive:true },
    { key:'slowEnemy', label:'Slow Enemy (10s)',      rarity:0.65, duration:10000, kind:'slow',   positive:true, appliesToEnemy:true }
  ];

  const BUFF_INVERTED_EXTRA = [
    { key:'normalize', label:'Normalize (10s)', rarity:0.45, duration:10000, kind:null, positive:true, global:true }
  ];

  function buffsForLevel(){
    if (game.level.theme === 'inverted') return BUFFS_BASE.concat(BUFF_INVERTED_EXTRA);
    return BUFFS_BASE;
  }

  function getActiveObstacles(){
    if (!game.options || game.options.enableCover === false) return [];
    return (game.level.obstacles || []);
  }

  function weightedPick(items){
    const total = items.reduce((s,it)=>s+it.rarity,0);
    let r = Math.random()*total;
    for (const it of items) { r -= it.rarity; if (r<=0) return it; }
    return items[items.length-1];
  }

  function randomSafeSpot(w,h){
    for (let i=0;i<60;i++){
      const x = rand(120, W-120-w);
      const y = rand(60, H-140-h);
      const test = { x,y,w,h };
      let ok = true;
      for (const p of game.level.platforms) if (aabb(test,p)) { ok=false; break; }
      for (const o of getActiveObstacles()) if (aabb(test,o)) { ok=false; break; }
      if (ok) return { x,y };
    }
    return { x: (W/2)-w/2, y: 80 };
  }

  function spawnBuff(){
    if (!game.options || game.options.enableBuffs === false) return;
    const all = buffsForLevel();
    const b = weightedPick(all);

    for (let tries=0; tries<30; tries++){
      const x = rand(140, W-140);
      const y = rand(60, H-240);
      const rect = { x,y,w:26,h:26 };
      if (P1 && aabb(rect,P1)) continue;
      if (P2 && aabb(rect,P2)) continue;

      let bad=false;
      for (const p of game.level.platforms) if (aabb(rect,p)) { bad=true; break; }
      if (bad) continue;

      game.buffsOnMap.push({ type:b.key, label:b.label, x,y,w:26,h:26, bob:Math.random()*10 });
      return;
    }
  }

  function applyBuffResult(collector, key, correct){
    const enemy = (collector===P1)?P2:P1;
    const all = buffsForLevel();
    const buff = all.find(x=>x.key===key);
    if (!buff) return;

    const overrideCollector = ()=>clearEffect(collector);
    const overrideEnemy = ()=>clearEffect(enemy);

    if (buff.positive) {
      if (!correct) return;

      // normalize (global, inverted level)
      if (key === 'normalize') {
        if (game.level.theme === 'inverted') setGlobal('normalizeWorld', buff.duration);
        return;
      }

      if (key === 'teleport') {
        overrideCollector();
        const spot = randomSafeSpot(collector.w, collector.h);
        collector.x = spot.x; collector.y = spot.y; collector.vx=0; collector.vy=0;
        return;
      }

      if (key === 'swapIt') {
        overrideCollector();
        collector.isIt = false;
        enemy.isIt = true;
        return;
      }

      if (key === 'slowEnemy') {
        overrideEnemy();
        setEffect(enemy, 'slow', buff.duration);
        return;
      }

      overrideCollector();
      setEffect(collector, buff.kind, buff.duration);
      return;
    }

    // harmful: invert controls
    if (buff.harmful && key === 'invert') {
      if (correct) { overrideEnemy(); setEffect(enemy,'invert',buff.duration); }
      else { overrideCollector(); setEffect(collector,'invert',buff.duration); }
    }
  }

  function tryCollectBuff(p){
    if (!p) return;
    for (let i=0;i<game.buffsOnMap.length;i++){
      const b = game.buffsOnMap[i];
      if (!aabb(p,b)) continue;

      game.buffsOnMap.splice(i,1);

      const q = makeQuestion(game.config.grade, game.config.qtype);
      const icon = game.level.buffIcons[b.type] || '‚òÖ';
      showQuestion({
        who: p,
        reason: `${icon} ${b.label}`,
        q: {
          text: q.text,
          check: q.check,
          onResolve: (ok)=>applyBuffResult(p, b.type, ok)
        }
      });
      return;
    }
  }

  // ---------------- Tagging (reliable) ----------------
  function tryStartTagQuestion(){
    if (game.state !== 'play') return;
    if (!P1 || !P2) return;

    const overlap = aabb(P1, P2);
    if (!overlap) {
      game.tagLatch = false;
      return;
    }

    // Only trigger once per ‚Äúcontact session‚Äù
    if (game.tagLatch) return;

    const tagger = P1.isIt ? P1 : P2;
    const other  = (tagger === P1) ? P2 : P1;

    if (tagger.tagCooldown > 0) {
      game.tagLatch = true;
      return;
    }

    tagger.tagCooldown = 550;
    game.tagLatch = true;

    const q = makeQuestion(game.config.grade, game.config.qtype);
    showQuestion({
      who: tagger,
      reason: 'Tag attempt',
      q: {
        text: q.text,
        check: q.check,
        onResolve: (ok)=>{ if (ok) { tagger.isIt=false; other.isIt=true; } }
      }
    });
  }

  // ---------------- Drawing ----------------
  function roundedRect(x,y,w,h,r){
    r = Math.min(r,w/2,h/2);
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  function drawParkBG(t){
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,'#78c8ff');
    g.addColorStop(0.45,'#bfeaff');
    g.addColorStop(1,'#1b5a34');
    ctx.fillStyle=g; ctx.fillRect(0,0,W,H);


// Skyline (background decoration)
ctx.save();
ctx.globalAlpha = 0.16;
ctx.fillStyle = '#0a2c3f';
const baseY = H*0.62;
for (let i=0;i<18;i++){
  const bw = 28 + ((i*37)%40);
  const bh = 60 + ((i*53)%120);
  const bx = (i/18)*W + ((i*17)%20) - 10;
  ctx.fillRect(bx, baseY-bh, bw, bh);

  // tiny windows
  ctx.globalAlpha = 0.07;
  ctx.fillStyle = '#ffffff';
  for (let wy=baseY-bh+12; wy<baseY-14; wy+=16){
    ctx.fillRect(bx+6, wy, 4, 6);
    ctx.fillRect(bx+14, wy, 4, 6);
  }
  ctx.globalAlpha = 0.16;
  ctx.fillStyle = '#0a2c3f';
}
ctx.restore();

    ctx.fillStyle='rgba(20,120,60,.35)';
    ctx.beginPath();
    ctx.moveTo(0,H*0.65);
    for (let x=0;x<=W;x+=80){
      ctx.quadraticCurveTo(x+40, H*0.56 + 12*Math.sin((t/900)+x/180), x+80, H*0.65);
    }
    ctx.lineTo(W,H); ctx.lineTo(0,H); ctx.closePath(); ctx.fill();

    ctx.fillStyle='rgba(25,120,55,.92)';
    ctx.fillRect(0, H-game.level.groundH, W, game.level.groundH);

    ctx.save();
    ctx.globalAlpha = 0.10;
    ctx.fillStyle = '#ffffff';
    ctx.font = '900 90px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('PARK', W/2, 120);
    ctx.restore();
  }

  function drawSpaceBG(t){
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,'#040615');
    g.addColorStop(0.6,'#070a22');
    g.addColorStop(1,'#120827');
    ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

    for (let i=0;i<240;i++){
      const x=(i*79)%W;
      const y=(i*137)%(H-80);
      const tw=0.25+0.75*Math.abs(Math.sin(t/850 + i*0.9));
      ctx.globalAlpha=0.12+0.55*tw;
      ctx.fillStyle='white';
      ctx.fillRect(x,y,2,2);
    }
    ctx.globalAlpha=1;


// Space decorations (background)
ctx.save();
// big ringed planet (now used as a cover object in obstacles)
// small sun
ctx.globalAlpha = 0.22;
ctx.fillStyle = '#ffd27a';
ctx.beginPath(); ctx.arc(W*0.16, H*0.18, 26, 0, Math.PI*2); ctx.fill();

// tiny rocket
ctx.globalAlpha = 0.24;
const rx = W*0.26, ry = H*0.32;
ctx.fillStyle = '#ffffff';
roundedRect(rx, ry, 18, 40, 8); ctx.fill();
ctx.fillStyle = '#ff7a7a';
ctx.beginPath(); ctx.moveTo(rx+9, ry-14); ctx.lineTo(rx, ry+8); ctx.lineTo(rx+18, ry+8); ctx.closePath(); ctx.fill();
ctx.fillStyle = '#7bd4ff';
ctx.beginPath(); ctx.arc(rx+9, ry+20, 5, 0, Math.PI*2); ctx.fill();

// little alien
ctx.globalAlpha = 0.22;
const ax = W*0.58, ay = H*0.30;
ctx.fillStyle = '#7bffb2';
ctx.beginPath(); ctx.ellipse(ax, ay, 12, 16, 0, 0, Math.PI*2); ctx.fill();
ctx.fillStyle = '#0b1220';
ctx.beginPath(); ctx.arc(ax-4, ay-2, 3, 0, Math.PI*2); ctx.fill();
ctx.beginPath(); ctx.arc(ax+4, ay-2, 3, 0, Math.PI*2); ctx.fill();
ctx.restore();

    function blob(x,y,r,c){
      ctx.save();
      ctx.globalAlpha=0.28;
      const grd=ctx.createRadialGradient(x,y,0,x,y,r);
      grd.addColorStop(0,c);
      grd.addColorStop(1,'transparent');
      ctx.fillStyle=grd;
      ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }
    blob(W*0.26,H*0.32,240,'rgba(170,120,255,.95)');
    blob(W*0.74,H*0.38,260,'rgba(120,210,255,.95)');

    ctx.fillStyle='rgba(36,36,52,.92)';
    ctx.fillRect(0, H-game.level.groundH, W, game.level.groundH);

    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.fillStyle = '#ffffff';
    ctx.font = '900 90px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('SPACE', W/2, 120);
    ctx.restore();
  }

  function drawInvertedBG(t){
    // Warm ‚Äúupside-down cavern / sunset‚Äù vibe
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,'#1a0c1e');
    g.addColorStop(0.55,'#3b1330');
    g.addColorStop(1,'#0f0a12');
    ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

    // floating embers
    for (let i=0;i<120;i++){
      const x=(i*91 + (t/6))%W;
      const y=(i*57 + (t/14))%H;
      ctx.globalAlpha = 0.05 + 0.12*Math.abs(Math.sin(t/900 + i));
      ctx.fillStyle = 'rgba(255,190,120,1)';
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.globalAlpha=1;

    // ceiling strip
    ctx.fillStyle='rgba(255,255,255,.06)';
    ctx.fillRect(0,0,W,20);

    // watermark (flipped/upside-down for the Inverted level)
    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.fillStyle = '#ffffff';
    ctx.font = '900 80px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const wm = worldIsNormalized() ? 'INVERTED (NORMALIZED)' : 'INVERTED';
    ctx.translate(W/2, 120);
    ctx.rotate(Math.PI);   // upside-down
    ctx.scale(-1, 1);      // mirrored
    ctx.fillText(wm, 0, 0);
    ctx.restore();
  }

  
  function drawStormBG(t){
    // Dark stormy sky + neon haze
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,'#070a24');
    g.addColorStop(0.55,'#0b0f34');
    g.addColorStop(1,'#060816');
    ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

    // Neon haze blobs
    function blob(x,y,r,c){
      ctx.save();
      ctx.globalAlpha=0.22;
      const grd=ctx.createRadialGradient(x,y,0,x,y,r);
      grd.addColorStop(0,c);
      grd.addColorStop(1,'transparent');
      ctx.fillStyle=grd;
      ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }
    blob(W*0.22,H*0.22,240,'rgba(80,160,255,.95)');
    blob(W*0.72,H*0.30,280,'rgba(180,110,255,.88)');
    blob(W*0.55,H*0.18,200,'rgba(255,220,120,.75)');

    // City skyline silhouettes
    ctx.save();
    ctx.globalAlpha = 0.28;
    ctx.fillStyle = '#05070f';
    const baseY = H*0.70;
    for (let i=0;i<22;i++){
      const bw = 26 + ((i*41)%46);
      const bh = 70 + ((i*63)%160);
      const bx = (i/22)*W + ((i*19)%24) - 10;
      ctx.fillRect(bx, baseY-bh, bw, bh);
      // neon windows
      ctx.globalAlpha = 0.14;
      ctx.fillStyle = (i%3===0) ? 'rgba(120,255,255,.55)' : (i%3===1 ? 'rgba(255,90,200,.45)' : 'rgba(255,230,120,.35)');
      for (let wy=baseY-bh+14; wy<baseY-12; wy+=18){
        ctx.fillRect(bx+6, wy, 4, 7);
        ctx.fillRect(bx+14, wy, 4, 7);
      }
      ctx.globalAlpha = 0.28;
      ctx.fillStyle = '#05070f';
    }
    ctx.restore();

    // Clouds
    ctx.save();
    ctx.globalAlpha = 0.16;
    ctx.fillStyle = '#ffffff';
    const cx = (t/55)% (W+260) - 130;
    roundedRect(cx, 90, 320, 70, 40); ctx.fill();
    roundedRect(cx+210, 70, 360, 88, 46); ctx.fill();
    roundedRect(cx+520, 100, 300, 64, 40); ctx.fill();
    ctx.restore();

    // Rain
    ctx.save();
    ctx.globalAlpha = 0.20;
    ctx.strokeStyle = 'rgba(120,255,255,.65)';
    ctx.lineWidth = 2;
    for (let i=0;i<120;i++){
      const x = (i*97 + t*0.35) % (W+60) - 30;
      const y = (i*53 + t*0.75) % (H+60) - 60;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x-10, y+26);
      ctx.stroke();
    }
    ctx.restore();

    // Ground strip
    ctx.fillStyle='rgba(10,10,22,.92)';
    ctx.fillRect(0, H-game.level.groundH, W, game.level.groundH);

    // Big faint label
    ctx.save();
    ctx.globalAlpha = 0.10;
    ctx.fillStyle = '#ffffff';
    ctx.font = '900 90px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('STORM', W/2, 120);
    ctx.restore();
  }


function drawPlatforms(){
    for (const p of game.level.platforms) {
      if (p.kind === 'ground' || p.kind === 'ceiling') continue;

      if (p.kind === 'ice') {
        // slick platform
        if (game.level.theme === 'space') ctx.fillStyle='rgba(140,210,255,.60)';
        else if (game.level.theme === 'storm') ctx.fillStyle='rgba(80,160,255,.40)';
        else if (game.level.theme === 'inverted') ctx.fillStyle='rgba(255,200,120,.38)';
        else ctx.fillStyle='rgba(120,220,170,.40)';
        roundedRect(p.x,p.y,p.w,p.h,12); ctx.fill();
        ctx.save();
        ctx.globalAlpha = 0.45;
        ctx.fillStyle = 'rgba(255,255,255,.35)';
        roundedRect(p.x+6, p.y+3, p.w-12, Math.max(3, p.h*0.32), 10); ctx.fill();
        ctx.restore();
      } else if (game.level.theme === 'park') {
        ctx.fillStyle='rgba(35,160,80,.95)';
        roundedRect(p.x,p.y,p.w,p.h,10); ctx.fill();
        ctx.fillStyle='rgba(255,255,255,.12)';
        roundedRect(p.x,p.y,p.w,Math.max(6,p.h*0.35),10); ctx.fill();
      } else if (game.level.theme === 'space') {
        ctx.fillStyle='rgba(100,100,170,.38)';
        roundedRect(p.x,p.y,p.w,p.h,10); ctx.fill();
        ctx.fillStyle='rgba(255,255,255,.10)';
        roundedRect(p.x,p.y,p.w,Math.max(6,p.h*0.35),10); ctx.fill();
        ctx.strokeStyle='rgba(170,120,255,.30)';
        ctx.lineWidth=2;
        ctx.strokeRect(p.x+1,p.y+1,p.w-2,p.h-2);
        ctx.lineWidth=1;
      } else if (game.level.theme === 'storm') {
        // neon rooftop platforms
        ctx.fillStyle='rgba(80,160,255,.26)';
        roundedRect(p.x,p.y,p.w,p.h,10); ctx.fill();
        ctx.fillStyle='rgba(180,110,255,.10)';
        roundedRect(p.x,p.y,p.w,Math.max(6,p.h*0.35),10); ctx.fill();
        ctx.strokeStyle='rgba(255,220,120,.28)';
        ctx.lineWidth=2;
        ctx.strokeRect(p.x+1,p.y+1,p.w-2,p.h-2);
        ctx.lineWidth=1;
      } else {
        // inverted
        ctx.fillStyle='rgba(255,170,90,.24)';
        roundedRect(p.x,p.y,p.w,p.h,10); ctx.fill();
        ctx.fillStyle='rgba(255,255,255,.10)';
        roundedRect(p.x,p.y,p.w,Math.max(6,p.h*0.35),10); ctx.fill();
        ctx.strokeStyle='rgba(255,120,190,.22)';
        ctx.lineWidth=2;
        ctx.strokeRect(p.x+1,p.y+1,p.w-2,p.h-2);
        ctx.lineWidth=1;
      }
    }
  }

  function drawLaunchPads(){
    for (const lp of game.level.pads) {
      ctx.save();
      ctx.fillStyle='rgba(255,255,255,.16)';
      roundedRect(lp.x,lp.y,lp.w,lp.h,10); ctx.fill();
      ctx.fillStyle='rgba(255,255,255,.10)';
      roundedRect(lp.x+6,lp.y+3,lp.w-12,lp.h-6,10); ctx.fill();
      ctx.fillStyle='rgba(255,255,255,.92)';
      ctx.font='16px system-ui';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(lp.dir === 'up' ? '‚áß' : '‚á©', lp.x+lp.w/2, lp.y+lp.h/2+1);
      ctx.restore();
    }
  }

  function drawBuffs(t){
    ctx.save();
    ctx.font='18px system-ui';
    ctx.textAlign='center';
    ctx.textBaseline='middle';

    for (const b of game.buffsOnMap) {
      b.bob += 0.06;
      const bobY = Math.sin(b.bob + t/500) * 4;

      ctx.globalAlpha=0.18;
      ctx.fillStyle='#fff';
      ctx.beginPath();
      ctx.arc(b.x+b.w/2, b.y+b.h/2+bobY, 18, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha=1;

      ctx.fillStyle='rgba(0,0,0,.25)';
      roundedRect(b.x, b.y+bobY, b.w, b.h, 8); ctx.fill();
      ctx.fillStyle='rgba(255,255,255,.14)';
      roundedRect(b.x+2, b.y+2+bobY, b.w-4, b.h-4, 8); ctx.fill();

      const icon = game.level.buffIcons[b.type] || '‚òÖ';
      ctx.fillStyle='rgba(255,255,255,.95)';
      ctx.fillText(icon, b.x+b.w/2, b.y+b.h/2+bobY+1);
    }
    ctx.restore();
  }

  
  function drawObstacle(o, alpha=1){
  ctx.save();
  ctx.globalAlpha = alpha;

  if (game.level.theme === 'park') {
    if (o.type === 'bush') {
      // Bush: wide, opaque, great for hiding
      ctx.fillStyle = '#1f7a3a';
      roundedRect(o.x, o.y + o.h*0.20, o.w, o.h*0.80, 26); ctx.fill();
      ctx.beginPath();
      ctx.arc(o.x + o.w*0.18, o.y + o.h*0.45, o.h*0.38, 0, Math.PI*2);
      ctx.arc(o.x + o.w*0.45, o.y + o.h*0.35, o.h*0.48, 0, Math.PI*2);
      ctx.arc(o.x + o.w*0.74, o.y + o.h*0.46, o.h*0.40, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha *= 0.35;
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(o.x + o.w*0.12, o.y + o.h*0.55, o.w*0.18, o.h*0.08);
      ctx.globalAlpha = alpha;

    } else if (o.type === 'bench') {
      // Park bench (opaque cover on platforms)
      ctx.fillStyle = '#7a4a28';
      roundedRect(o.x, o.y + o.h*0.45, o.w, o.h*0.55, 10); ctx.fill();
      ctx.fillStyle = '#5a341d';
      roundedRect(o.x+6, o.y + o.h*0.55, o.w-12, o.h*0.18, 8); ctx.fill();
      ctx.fillStyle = '#2b1a10';
      ctx.fillRect(o.x+10, o.y + o.h*0.80, 8, o.h*0.20);
      ctx.fillRect(o.x+o.w-18, o.y + o.h*0.80, 8, o.h*0.20);
      ctx.globalAlpha *= 0.18;
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(o.x+8, o.y + o.h*0.58, o.w*0.35, o.h*0.10);
      ctx.globalAlpha = alpha;
    } else if (o.type === 'rock') {
      // Rock (opaque cover)
      ctx.fillStyle = '#3a4d52';
      roundedRect(o.x, o.y, o.w, o.h, 18); ctx.fill();
      ctx.globalAlpha *= 0.16;
      ctx.fillStyle = '#ffffff';
      ctx.beginPath(); ctx.arc(o.x+o.w*0.35, o.y+o.h*0.35, Math.min(o.w,o.h)*0.18, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = alpha;
    } else if (o.type === 'bigTree') {
      // Big tree: wide trunk + canopy that reaches high (can hide from platforms too)
      const trunkW = Math.max(80, o.w*0.52);
      const trunkX = o.x + (o.w - trunkW)/2;
      const trunkH = o.h*0.70;
      const trunkY = o.y + o.h - trunkH;

      ctx.fillStyle = '#5a3a1b';
      roundedRect(trunkX, trunkY, trunkW, trunkH, 18); ctx.fill();

      // canopy
      ctx.fillStyle = '#1d7b3a';
      ctx.beginPath();
      ctx.arc(o.x + o.w*0.50, o.y + o.h*0.26, o.w*0.40, 0, Math.PI*2);
      ctx.arc(o.x + o.w*0.25, o.y + o.h*0.33, o.w*0.32, 0, Math.PI*2);
      ctx.arc(o.x + o.w*0.76, o.y + o.h*0.34, o.w*0.34, 0, Math.PI*2);
      ctx.arc(o.x + o.w*0.38, o.y + o.h*0.15, o.w*0.28, 0, Math.PI*2);
      ctx.arc(o.x + o.w*0.62, o.y + o.h*0.14, o.w*0.28, 0, Math.PI*2);
      ctx.fill();

      // subtle highlight
      ctx.globalAlpha *= 0.22;
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(o.x + o.w*0.38, o.y + o.h*0.22, o.w*0.18, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = alpha;
    } else {
      // Regular tree
      const trunkW = Math.max(22, o.w*0.36);
      const trunkX = o.x + (o.w - trunkW)/2;
      const trunkH = o.h*0.62;
      const trunkY = o.y + o.h - trunkH;

      ctx.fillStyle = '#5a3a1b';
      roundedRect(trunkX, trunkY, trunkW, trunkH, 10); ctx.fill();

      ctx.fillStyle = '#1f7a3a';
      ctx.beginPath();
      ctx.arc(o.x + o.w*0.50, o.y + o.h*0.25, o.w*0.48, 0, Math.PI*2);
      ctx.arc(o.x + o.w*0.28, o.y + o.h*0.35, o.w*0.38, 0, Math.PI*2);
      ctx.arc(o.x + o.w*0.74, o.y + o.h*0.35, o.w*0.38, 0, Math.PI*2);
      ctx.fill();

      ctx.globalAlpha *= 0.18;
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(o.x + o.w*0.35, o.y + o.h*0.25, o.w*0.16, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = alpha;
    }
  } else if (game.level.theme === 'space') {
    if (o.type === 'asteroid') {
      ctx.fillStyle = '#b57bff';
      roundedRect(o.x, o.y, o.w, o.h, 18); ctx.fill();
      ctx.globalAlpha *= 0.20;
      ctx.fillStyle = '#ffffff';
      for (let i=0;i<4;i++){
        const cx = o.x + (0.22 + i*0.19)*o.w;
        const cy = o.y + (0.28 + (i%2)*0.22)*o.h;
        ctx.beginPath(); ctx.arc(cx, cy, 7 + i*2, 0, Math.PI*2); ctx.fill();
      }
      ctx.globalAlpha = alpha;
      ctx.strokeStyle = 'rgba(255,255,255,.55)';
      ctx.lineWidth = 2;
      ctx.strokeRect(o.x+2, o.y+2, o.w-4, o.h-4);
      ctx.lineWidth = 1;

    } else if (o.type === 'planet') {
      // Opaque ringed planet cover object (can hide behind)
      const cx = o.x + o.w/2, cy = o.y + o.h/2;
      const r = Math.min(o.w,o.h)*0.44;
      ctx.fillStyle = '#7bd4ff';
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();

      // subtle band
      ctx.globalAlpha *= 0.22;
      ctx.fillStyle = '#ffffff';
      ctx.beginPath(); ctx.ellipse(cx-6, cy+4, r*0.85, r*0.28, -0.25, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = alpha;

      // rings (still opaque enough to count as cover visually)
      ctx.strokeStyle = 'rgba(255,255,255,.70)';
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.ellipse(cx, cy, r*1.55, r*0.55, -0.35, 0, Math.PI*2);
      ctx.stroke();
      ctx.lineWidth = 1;
    } else {
      // crate
      ctx.fillStyle = '#62d6ff';
      roundedRect(o.x, o.y, o.w, o.h, 12); ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,.7)';
      ctx.lineWidth = 2;
      ctx.strokeRect(o.x+2, o.y+2, o.w-4, o.h-4);

      ctx.globalAlpha *= 0.22;
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(o.x+8, o.y+10, o.w-16, 7);
      ctx.globalAlpha = alpha;

      ctx.lineWidth = 1;
    }
} else if (game.level.theme === 'storm') {
  // Storm cover: neon purple/yellow pieces (opaque enough to hide behind)
  if (o.type === 'neonSign') {
    // Purple sign body
    ctx.fillStyle = 'rgba(170,90,255,.95)';
    roundedRect(o.x, o.y, o.w, o.h, 16); ctx.fill();

    // Yellow glow strip
    ctx.globalAlpha *= 0.95;
    ctx.fillStyle = 'rgba(255,230,120,.95)';
    roundedRect(o.x+10, o.y+12, o.w-20, Math.max(10, o.h*0.18), 999); ctx.fill();

    // Neon edge
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = 'rgba(120,210,255,.75)';
    ctx.lineWidth = 2;
    ctx.strokeRect(o.x+2, o.y+2, o.w-4, o.h-4);
    ctx.lineWidth = 1;

  } else if (o.type === 'vent') {
    // Violet metal vent with yellow highlights
    ctx.fillStyle = 'rgba(90,120,255,.55)';
    roundedRect(o.x, o.y, o.w, o.h, 14); ctx.fill();

    ctx.globalAlpha *= 0.9;
    ctx.fillStyle = 'rgba(255,230,120,.75)';
    for (let i=0;i<4;i++){
      const yy = o.y + 10 + i*(o.h-20)/3;
      roundedRect(o.x+10, yy, o.w-20, 6, 6); ctx.fill();
    }
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = 'rgba(180,110,255,.70)';
    ctx.lineWidth = 2;
    ctx.strokeRect(o.x+2, o.y+2, o.w-4, o.h-4);
    ctx.lineWidth = 1;

  } else {
    // fallback neon pillar
    ctx.fillStyle = 'rgba(170,90,255,.80)';
    roundedRect(o.x, o.y, o.w, o.h, 14); ctx.fill();
    ctx.globalAlpha *= 0.22;
    ctx.fillStyle = 'rgba(255,230,120,.65)';
    roundedRect(o.x+8, o.y+12, o.w-16, o.h-24, 12); ctx.fill();
    ctx.globalAlpha = alpha;
  }

} else {
  // Inverted pillar (opaque)

    ctx.fillStyle = '#ff8c4a';
    roundedRect(o.x, o.y, o.w, o.h, 14); ctx.fill();
    ctx.globalAlpha *= 0.20;
    ctx.fillStyle = '#ffffff';
    roundedRect(o.x+8, o.y+12, o.w-16, o.h-24, 12); ctx.fill();
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = 'rgba(255,120,190,.65)';
    ctx.lineWidth = 2;
    ctx.strokeRect(o.x+2, o.y+2, o.w-4, o.h-4);
    ctx.lineWidth = 1;
  }

  ctx.restore();
}

  
function drawActors(){
  // Painter's algorithm: draw things from back-to-front based on their bottom edge.
  // This lets cover objects hide players naturally without "double-drawing" (no lighting up).
  const items = [];
  const obs = getActiveObstacles();
  for (const o of obs) items.push({ kind:'obs', z: o.y + o.h, obj: o });
  if (P1) items.push({ kind:'p', z: P1.y + P1.h, obj: P1 });
  if (P2) items.push({ kind:'p', z: P2.y + P2.h, obj: P2 });

  items.sort((a,b)=>{
    if (a.z !== b.z) return a.z - b.z;
    // If bottoms tie, draw obstacles AFTER players so you can hide behind them even on the ground.
    if (a.kind === 'obs' && b.kind === 'p') return 1;
    if (a.kind === 'p' && b.kind === 'obs') return -1;
    return 0;
  });

  for (const it of items){
    if (it.kind === 'obs') drawObstacle(it.obj, 1);
    else drawPlayer(it.obj);
  }
}

function drawPlayer(p){
    if (!p) return;

    ctx.save();

    const invis = (effectKind(p) === 'invis');
    const bodyA = invis ? 0.18 : 1.0;

    // glow (faint when invisible)
    ctx.globalAlpha = invis ? 0.10 : 0.18;
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(p.x+p.w/2, p.y+p.h/2, 26, 0, Math.PI*2);
    ctx.fill();

    // body
    ctx.globalAlpha = bodyA;
    ctx.fillStyle = p.color;
    roundedRect(p.x,p.y,p.w,p.h,10); ctx.fill();

    // outline
    ctx.globalAlpha = bodyA;
    ctx.strokeStyle='rgba(0,0,0,.65)';
    ctx.lineWidth=3;
    ctx.strokeRect(p.x+0.5,p.y+0.5,p.w-1,p.h-1);

    // eye
    ctx.fillStyle='rgba(255,255,255,.92)';
    const eyeX = p.x + (p.facing>0 ? 22 : 12);
    const eyeY = p.y + 16;
    ctx.beginPath(); ctx.arc(eyeX,eyeY,3,0,Math.PI*2); ctx.fill();

    // IT border + label (hide when invisible)
    if (!invis) {
      if (p.isIt) {
        ctx.globalAlpha = 1;
        ctx.strokeStyle='rgba(255,215,80,.98)';
        ctx.lineWidth=4;
        ctx.strokeRect(p.x-3,p.y-3,p.w+6,p.h+6);
      }
      ctx.font='900 12px system-ui';
      ctx.textAlign='center'; ctx.textBaseline='bottom';
      ctx.fillStyle='rgba(255,255,255,.95)';
      ctx.fillText(p.id, p.x+p.w/2, p.y-6);
    }

    ctx.restore();
  }

  function drawHUD(){
    if (!P1 || !P2) { hudEl.textContent = ''; return; }

    const it = P1.isIt ? P1 : P2;
    const lineFor = (p)=>{
      const k = effectKind(p);
      if (!k) return '‚Äî';
      const s = Math.ceil(Math.max(0, p.effect.until - nowMs())/1000);
      const label = ({speed:'Speed',jump:'Jump',both:'Speed+Jump',invert:'Invert',slow:'Slowed',invis:'Invisible'})[k] || k;
      return `${label} ‚Ä¢ ${s}s`;
    };

    let globalLine = '';
    if (game.level.theme === 'inverted') {
      if (globalActive('normalizeWorld')) {
        const s = Math.ceil(Math.max(0, game.globalEffect.until - nowMs())/1000);
        globalLine = `üß≠ Normalize active ‚Ä¢ ${s}s`;
      } else {
        globalLine = `üôÉ Inverted rules active`;
      }
    }

    hudEl.innerHTML = `
      <div style="display:flex; gap:10px; align-items:center; margin-bottom:8px; flex-wrap:wrap;">
        <span class="pill"><span class="dot" style="background:${it.color};"></span> IT: ${it.id}</span>
        <span style="opacity:.92; font-weight:1000;">${game.level.name} ‚Ä¢ ${game.config.grade} ‚Ä¢ ${game.config.qtype}</span>
        ${globalLine ? `<span style="opacity:.9; font-weight:1000;">${globalLine}</span>` : ``}
      </div>
      <div style="display:grid; gap:6px;">
        <div><b style="color:${P1.color};">P1</b> ‚Äî ${lineFor(P1)}</div>
        <div><b style="color:${P2.color};">P2</b> ‚Äî ${lineFor(P2)}</div>
      </div>
    `;
  }

  // ---------------- Update / Render ----------------
  function update(dt){
    if (game.state !== 'play') return;

    // expire global effect
    if (game.globalEffect.kind && nowMs() >= game.globalEffect.until) clearGlobal();
    // Storm wind (noticeable, but not ridiculous)
    if (game.level.theme === 'storm') {
      const n = nowMs();
      if (!game.wind) game.wind = { dir: 0, v: 0, targetV: 0, nextChange: 0, gustUntil: 0 };
      if (!Number.isFinite(game.wind.v)) game.wind.v = 0;
      if (!Number.isFinite(game.wind.targetV)) game.wind.targetV = 0;

      // Direction changes every couple seconds (sometimes calm)
      if (!game.wind.nextChange || n >= game.wind.nextChange) {
        const r = Math.random();
        game.wind.dir = (r < 0.36) ? -1 : (r < 0.72 ? 1 : 0);

        // Base breeze speed (px/s). Typical walk speed is ~250 px/s.
        // We keep wind as a smaller, persistent influence.
        const base = (game.wind.dir === 0) ? rand(0, 25) : rand(45, 120);
        game.wind.targetV = base;

        // next change
        game.wind.nextChange = n + rand(1200, 2400);

        // occasional gust bursts (adds some chaos)
        if (game.wind.dir !== 0 && Math.random() < 0.45) {
          game.wind.gustUntil = n + rand(450, 900);
        } else {
          game.wind.gustUntil = 0;
        }
      }

      // gust boosts target temporarily
      let tgt = game.wind.targetV;
      if (game.wind.gustUntil && n < game.wind.gustUntil) {
        tgt += rand(80, 220);
      }

      // small jitter so it feels alive
      tgt += (Math.random() - 0.5) * 18;

      // smoothly move current wind toward target (dt is ms)
      const lerp = 1 - Math.pow(0.004, dt); // responsive but not snappy
      game.wind.v = game.wind.v + (tgt - game.wind.v) * lerp;
    } else if (game.wind) {
      game.wind.dir = 0;
      game.wind.v = 0;
      game.wind.targetV = 0;
      game.wind.nextChange = 0;
      game.wind.gustUntil = 0;
    }
updatePlayer(P1, dt);
    updatePlayer(P2, dt);
// spawn buffs
    if (!game.options || game.options.enableBuffs === false) {
      game.buffsOnMap = [];
      game.buffSpawnTimer = 99999999;
    } else {
      game.buffSpawnTimer -= dt;
      if (game.buffSpawnTimer <= 0 && game.buffsOnMap.length < 4) {
        spawnBuff();
        game.buffSpawnTimer = rand(6000, 9500);
      }
    }

    tryCollectBuff(P1);
    if (game.state !== 'play') return;
    tryCollectBuff(P2);

    // reliable tag check
    tryStartTagQuestion();
  }

function drawCountdown(){
  if (game.state !== 'play') return;
  const now = nowMs();
  if (game.headstartUntil && now < game.headstartUntil) {
    const n = Math.ceil((game.headstartUntil - now)/1000);
    ctx.save();
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = 'rgba(0,0,0,.28)';
    roundedRect(W/2-62, 18, 124, 78, 18); ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,.95)';
    ctx.font = '900 54px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(String(n), W/2, 58);
    ctx.restore();
  }
}

  function render(t){
    ctx.globalAlpha = 1;

    const inHeadstart = (game.headstartUntil && nowMs() < game.headstartUntil);
    if (timerPanelEl) timerPanelEl.style.visibility = inHeadstart ? 'hidden' : 'visible';
    if (timerValEl && !inHeadstart) timerValEl.textContent = formatTime(nowMs() - game.startTimeMs);

    if (game.level.theme === 'park') drawParkBG(t);
    else if (game.level.theme === 'space') drawSpaceBG(t);
    else if (game.level.theme === 'storm') drawStormBG(t);
    else drawInvertedBG(t);

    // wind icon
    if (windIconEl) {
      if (game.level.theme === 'storm' && game.state === 'play') {
        const d = (game.wind && game.wind.dir) ? game.wind.dir : 0;
        windIconEl.style.display = 'inline-flex';
        const v = (game.wind && game.wind.v) ? game.wind.v : 0;
        const mag = Math.min(3, Math.floor(v/160));
        const bars = (d===0) ? '' : ' ' + '‚ñÆ'.repeat(Math.max(1,mag));
        windIconEl.textContent = (d === 0) ? 'üåÄ Wind: calm' : (d < 0 ? 'üí® Wind: ‚Üê' : 'üí® Wind: ‚Üí') + bars;
      } else {
        windIconEl.style.display = 'none';
      }
    }

    drawPlatforms();
    drawLaunchPads();
    drawBuffs(t);
    drawActors();

    drawCountdown();

    drawHUD();
  }

  function tick(t){
    try {
      const dt = clamp(t - game.lastT, 0, 33);
      game.lastT = t;
      update(dt);
      render(t);
      requestAnimationFrame(tick);
    } catch (err) {
      showFatal(err);
      // stop loop
    }
  }

  // ---------------- Start Game ----------------
  function startGame(){
    showSplash(false);
    // apply splash toggles
    game.options.enableBuffs = !!buffsEnabled;
    game.options.enableCover = !!coverEnabled;
    game.state = 'play';
    game.buffsOnMap = [];
    game.buffSpawnTimer = game.options.enableBuffs ? rand(1400, 2600) : 99999999;
    game.lastOverlap = false;
    game.tagLatch = false;
    clearGlobal();
    resetPlayers(false);

    game.startTimeMs = nowMs();
    const it = P1.isIt ? P1 : P2;
    game.headstartItId = it.id;
    game.headstartUntil = nowMs() + 3000;
  }

  // ---------------- Boot ----------------
  resetPlayers(true);
  showSplash(true);
  requestAnimationFrame((t)=>{ game.lastT = t; tick(t); });

})();
</script>
</body>
</html>
