
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Math Tag Park (2P)</title>
  <style>
    html, body { height: 100%; margin: 0; background: #0b1b10; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #wrap { height: 100%; display: grid; place-items: center; }
    canvas { background: #0f2a18; border: 2px solid rgba(255,255,255,.12); border-radius: 14px; box-shadow: 0 10px 30px rgba(0,0,0,.35); }
    #ui {
      position: fixed; left: 14px; top: 12px; right: 14px;
      display: flex; gap: 12px; align-items: flex-start; justify-content: space-between;
      pointer-events: none;
      color: rgba(255,255,255,.92);
      text-shadow: 0 2px 12px rgba(0,0,0,.6);
      font-size: 14px;
    }
    .panel {
      pointer-events: none;
      background: rgba(0,0,0,.28);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      padding: 10px 12px;
      backdrop-filter: blur(6px);
      max-width: 520px;
      line-height: 1.25;
    }
    .title { font-weight: 700; letter-spacing: .2px; margin-bottom: 6px; }
    .kbd { display: inline-block; padding: 2px 6px; border-radius: 8px; background: rgba(255,255,255,.12); border: 1px solid rgba(255,255,255,.14); margin: 0 2px; }
    #overlay {
      position: fixed; inset: 0;
      display: none;
      align-items: center; justify-content: center;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(6px);
      z-index: 10;
    }
    #card {
      width: min(560px, calc(100vw - 28px));
      background: rgba(12,20,14,.92);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 16px;
      box-shadow: 0 18px 50px rgba(0,0,0,.45);
      padding: 16px 16px 14px;
      color: rgba(255,255,255,.94);
    }
    #qTop { display: flex; gap: 10px; align-items: center; justify-content: space-between; }
    #whoTag { font-weight: 800; }
    #prompt { margin: 12px 0 10px; font-size: 20px; font-weight: 800; letter-spacing: .2px; }
    #sub { opacity: .85; font-size: 13px; margin-bottom: 10px; }
    #row { display: flex; gap: 10px; align-items: center; }
    #ans {
      flex: 1;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.95);
      font-size: 16px;
      outline: none;
    }
    #btn {
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.20);
      background: rgba(90,220,120,.18);
      color: rgba(255,255,255,.95);
      font-weight: 800;
      cursor: pointer;
    }
    #btn:active { transform: translateY(1px); }
    #msg { margin-top: 10px; min-height: 18px; font-weight: 700; }
    #tiny { opacity: .78; font-size: 12px; margin-top: 8px; }
    .pill {
      display: inline-flex; align-items: center; gap: 8px;
      padding: 5px 10px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.08);
      font-weight: 800;
    }
    .dot { width: 10px; height: 10px; border-radius: 50%; }
    .blue { background: #39a9ff; }
    .red { background: #ff4b4b; }
  </style>
</head>
<body>
  <div id="ui">
    <div class="panel">
      <div class="title">Math Tag Park</div>
      <div>
        Blue: <span class="kbd">W</span> jump, <span class="kbd">A</span>/<span class="kbd">D</span> move ‚Ä¢
        Red: <span class="kbd">‚Üë</span> jump, <span class="kbd">‚Üê</span>/<span class="kbd">‚Üí</span> move ‚Ä¢
        Double jump always on.
      </div>
      <div style="margin-top:6px; opacity:.9;">
        Tag by colliding ‚Üí the <b>initiator</b> answers a math question to pass ‚Äúit‚Äù.
        Buffs require a math question too.
      </div>
    </div>
    <div class="panel" id="hudPanel">
      <div class="title">Status</div>
      <div id="hud"></div>
    </div>
  </div>

  <div id="wrap">
    <canvas id="c" width="1100" height="650"></canvas>
  </div>

  <div id="overlay">
    <div id="card">
      <div id="qTop">
        <div class="pill"><span class="dot" id="whoDot"></span><span id="whoTag">Blue</span> answers</div>
        <div style="opacity:.9; font-weight:800;" id="reason">Tag attempt</div>
      </div>
      <div id="prompt">What is 7 √ó 8?</div>
      <div id="sub">Type your answer and press Enter.</div>
      <div id="row">
        <input id="ans" autocomplete="off" inputmode="numeric" placeholder="Answer‚Ä¶" />
        <button id="btn">Submit</button>
      </div>
      <div id="msg"></div>
      <div id="tiny">Tip: fractions like 3/4 are okay. Decimals too.</div>
    </div>
  </div>

<script>
(() => {
  // ---------- Canvas ----------
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const W = canvas.width, H = canvas.height;

  // ---------- Overlay / Question UI ----------
  const overlay = document.getElementById('overlay');
  const promptEl = document.getElementById('prompt');
  const ansEl = document.getElementById('ans');
  const msgEl = document.getElementById('msg');
  const whoTagEl = document.getElementById('whoTag');
  const whoDot = document.getElementById('whoDot');
  const reasonEl = document.getElementById('reason');
  const btn = document.getElementById('btn');
  const hudEl = document.getElementById('hud');

  let pausedForQuestion = false;
  let pendingQuestion = null; // { text, check(answerString)->bool, onResolve(correct) }
  let lastQuestionTime = 0;

  function showQuestion({ who, reason, q }) {
    pausedForQuestion = true;
    overlay.style.display = 'flex';
    msgEl.textContent = '';
    pendingQuestion = { ...q, who, reason };

    promptEl.textContent = q.text;
    reasonEl.textContent = reason;
    whoTagEl.textContent = who.name;
    whoDot.className = 'dot ' + (who.id === 'P1' ? 'blue' : 'red');

    ansEl.value = '';
    ansEl.focus();
  }

  function closeQuestion() {
    overlay.style.display = 'none';
    pausedForQuestion = false;
    pendingQuestion = null;
  }

  function normalizeAnswer(s) {
    return (s ?? '').toString().trim().replace(/\s+/g, '');
  }

  function parseMaybeNumberOrFraction(s) {
    s = normalizeAnswer(s);
    if (!s) return null;

    // Fraction like a/b
    if (s.includes('/')) {
      const [a, b] = s.split('/');
      const na = Number(a), nb = Number(b);
      if (!Number.isFinite(na) || !Number.isFinite(nb) || nb === 0) return null;
      return na / nb;
    }

    // Simple number
    const n = Number(s);
    if (!Number.isFinite(n)) return null;
    return n;
  }

  function submitAnswer() {
    if (!pendingQuestion) return;
    const raw = ansEl.value;
    const ok = pendingQuestion.check(raw);

    msgEl.textContent = ok ? '‚úÖ Correct!' : '‚ùå Not quite.';
    msgEl.style.color = ok ? 'rgba(140,255,170,.95)' : 'rgba(255,160,160,.95)';

    // Resolve after a short beat
    setTimeout(() => {
      const onResolve = pendingQuestion.onResolve;
      closeQuestion();
      onResolve(ok);
      lastQuestionTime = performance.now();
    }, 420);
  }

  btn.addEventListener('click', submitAnswer);
  ansEl.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') submitAnswer();
    if (e.key === 'Escape') {
      // Escape = treat as incorrect (keeps game moving)
      if (!pendingQuestion) return;
      msgEl.textContent = '‚ùå Skipped (counts as incorrect).';
      msgEl.style.color = 'rgba(255,160,160,.95)';
      setTimeout(() => {
        const onResolve = pendingQuestion.onResolve;
        closeQuestion();
        onResolve(false);
        lastQuestionTime = performance.now();
      }, 420);
    }
  });

  // ---------- Input ----------
  const keys = new Set();
  window.addEventListener('keydown', (e) => {
    if (pausedForQuestion) return;
    keys.add(e.key);
  });
  window.addEventListener('keyup', (e) => keys.delete(e.key));

  // ---------- Helpers ----------
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function rand(a, b) { return a + Math.random() * (b - a); }
  function randi(a, b) { return Math.floor(rand(a, b)); }

  function aabbOverlap(a, b) {
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  function resolveAABB(m, s) {
    // Move m out of s along smallest overlap axis
    const dx1 = (s.x + s.w) - m.x;
    const dx2 = (m.x + m.w) - s.x;
    const dy1 = (s.y + s.h) - m.y;
    const dy2 = (m.y + m.h) - s.y;

    const ox = Math.min(dx1, dx2);
    const oy = Math.min(dy1, dy2);

    if (ox < oy) {
      // push in x
      if (dx1 < dx2) m.x = s.x + s.w;
      else m.x = s.x - m.w;
      m.vx = 0;
      return { axis: 'x' };
    } else {
      // push in y
      if (dy1 < dy2) {
        m.y = s.y + s.h;
        m.vy = Math.max(0, m.vy);
        return { axis: 'y', from: 'top' }; // m is below
      } else {
        m.y = s.y - m.h;
        m.vy = 0;
        m.onGround = true;
        m.jumpsLeft = 2;
        return { axis: 'y', from: 'bottom' }; // landed on platform
      }
    }
  }

  function drawRoundedRect(x, y, w, h, r) {
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
    ctx.fill();
  }

  // ---------- World / Platforms ----------
  const ground = { x: 0, y: H - 48, w: W, h: 48, type: 'ground' };

  // Ensure launchpad clearance: keep corners open above pads.
  const launchPadSize = { w: 80, h: 14 };
  const launchPads = [
    { x: 14, y: H - 48 - launchPadSize.h, w: launchPadSize.w, h: launchPadSize.h, side: 'L' },
    { x: W - 14 - launchPadSize.w, y: H - 48 - launchPadSize.h, w: launchPadSize.w, h: launchPadSize.h, side: 'R' }
  ];

  // Nature platforms (no platforms above launchpads)
  const platforms = [
    ground,

    // mid-low
    { x: 160, y: H - 170, w: 220, h: 20 },
    { x: W - 160 - 220, y: H - 170, w: 220, h: 20 },

    // middle
    { x: (W/2) - 170, y: H - 270, w: 340, h: 22 },

    // upper left / right
    { x: 170, y: H - 360, w: 210, h: 20 },
    { x: W - 170 - 210, y: H - 360, w: 210, h: 20 },

    // top-ish
    { x: (W/2) - 120, y: H - 450, w: 240, h: 18 },

    // small stepping stones
    { x: (W/2) - 420, y: H - 430, w: 120, h: 16 },
    { x: (W/2) + 300, y: H - 430, w: 120, h: 16 },

    // NOTE: no platforms in "launchpad columns"
  ];

  // Safe spots for teleport
  function randomSafeSpot(entityW, entityH) {
    // Try a few random points, else fallback center
    for (let i = 0; i < 60; i++) {
      const x = rand(110, W - 110 - entityW);
      const y = rand(60, H - 140 - entityH);
      const test = { x, y, w: entityW, h: entityH };
      // avoid launchpad columns (keep them clear)
      const leftCol = x < 120;
      const rightCol = x + entityW > W - 120;
      if (leftCol || rightCol) continue;

      let ok = true;
      for (const p of platforms) if (aabbOverlap(test, p)) { ok = false; break; }
      if (ok) return { x, y };
    }
    return { x: (W/2) - entityW/2, y: 80 };
  }

  // ---------- Players ----------
  const base = {
    w: 34, h: 46,
    speed: 250,
    jumpV: 520,
    gravity: 1400,
    maxFall: 950
  };

  function makePlayer(id, name, color, startX, startY, controls) {
    return {
      id, name, color,
      x: startX, y: startY, w: base.w, h: base.h,
      vx: 0, vy: 0,
      onGround: false,
      jumpsLeft: 2,
      facing: 1,
      controls,
      isIt: false,
      // effect timers (ms remaining)
      speedBoost: 0,
      jumpBoost: 0,
      invert: 0,
      slow: 0, // applied to THIS player when enemy slows you
      // cooldown so you don't re-trigger tag every frame
      tagCooldown: 0
    };
  }

  const P1 = makePlayer('P1', 'Blue', '#39a9ff', 220, H - 260, {
    left: 'a', right: 'd', jump: 'w'
  });
  const P2 = makePlayer('P2', 'Red', '#ff4b4b', W - 260, H - 260, {
    left: 'ArrowLeft', right: 'ArrowRight', jump: 'ArrowUp'
  });

  // Randomly decide who starts "it"
  (Math.random() < 0.5 ? P1 : P2).isIt = true;

  // ---------- Buffs ----------
  const BUFFS = [
    { key: 'speed', label: 'Superspeed (10s)', rarity: 1.0 },
    { key: 'jump', label: 'Higher Jumps (10s)', rarity: 1.0 },
    { key: 'both', label: 'Jump+Speed (10s)', rarity: 0.45 },
    { key: 'swapIt', label: 'Make other ‚Äúit‚Äù', rarity: 0.12 },
    { key: 'invert', label: 'Invert controls (10s)', rarity: 0.55, debuff: true },
    { key: 'teleport', label: 'Teleporter', rarity: 0.7 },
    { key: 'slowEnemy', label: 'Slow enemy (10s)', rarity: 0.65 }
  ];

  const buffIcons = {
    speed: '‚ö°', jump: 'ü¶ò', both: '‚ú®', swapIt: 'üëë', invert: 'üîÅ', teleport: 'üåÄ', slowEnemy: 'üßä'
  };

  const buffColors = {
    speed: 'rgba(255,255,255,.90)',
    jump: 'rgba(255,255,255,.90)',
    both: 'rgba(255,255,255,.90)',
    swapIt: 'rgba(255,255,255,.90)',
    invert: 'rgba(255,255,255,.90)',
    teleport: 'rgba(255,255,255,.90)',
    slowEnemy: 'rgba(255,255,255,.90)'
  };

  let buffsOnMap = [];
  let buffSpawnTimer = 0;

  function weightedPick(items) {
    const total = items.reduce((s, it) => s + it.rarity, 0);
    let r = Math.random() * total;
    for (const it of items) {
      r -= it.rarity;
      if (r <= 0) return it;
    }
    return items[items.length - 1];
  }

  function spawnBuff() {
    const b = weightedPick(BUFFS);
    // spawn away from players and away from launchpad columns
    for (let t = 0; t < 30; t++) {
      const x = rand(140, W - 140);
      const y = rand(80, H - 220);
      if (x < 140 || x > W - 140) continue;
      const rect = { x, y, w: 26, h: 26 };
      if (aabbOverlap(rect, P1) || aabbOverlap(rect, P2)) continue;
      let bad = false;
      for (const p of platforms) if (aabbOverlap(rect, p)) { bad = true; break; }
      if (bad) continue;
      buffsOnMap.push({
        type: b.key,
        label: b.label,
        debuff: !!b.debuff,
        x, y, w: 26, h: 26,
        bob: 0
      });
      return;
    }
  }

  // ---------- Math Questions (Grade 5-ish) ----------
  function makeQuestion() {
    // Mix of: multi-digit ops, decimals, fractions, factors, perimeter/area, order of ops
    const types = ['add', 'sub', 'mul', 'div', 'dec', 'frac', 'area', 'perim', 'ops'];
    const t = types[randi(0, types.length)];

    const q = { text: '', check: () => false, onResolve: () => {} };

    if (t === 'add') {
      const a = randi(120, 900), b = randi(80, 700);
      const ans = a + b;
      q.text = `What is ${a} + ${b}?`;
      q.check = (s) => parseMaybeNumberOrFraction(s) === ans;
      return q;
    }

    if (t === 'sub') {
      const a = randi(200, 999), b = randi(30, 180);
      const ans = a - b;
      q.text = `What is ${a} ‚àí ${b}?`;
      q.check = (s) => parseMaybeNumberOrFraction(s) === ans;
      return q;
    }

    if (t === 'mul') {
      const a = randi(6, 24), b = randi(6, 24);
      const ans = a * b;
      q.text = `What is ${a} √ó ${b}?`;
      q.check = (s) => parseMaybeNumberOrFraction(s) === ans;
      return q;
    }

    if (t === 'div') {
      const b = randi(3, 12);
      const ans = randi(4, 18);
      const a = b * ans;
      q.text = `What is ${a} √∑ ${b}?`;
      q.check = (s) => parseMaybeNumberOrFraction(s) === ans;
      return q;
    }

    if (t === 'dec') {
      // one decimal place + one decimal place
      const a = randi(12, 89) / 10;
      const b = randi(12, 89) / 10;
      const ans = Math.round((a + b) * 10) / 10;
      q.text = `What is ${a.toFixed(1)} + ${b.toFixed(1)}?`;
      q.check = (s) => {
        const n = parseMaybeNumberOrFraction(s);
        return n !== null && Math.abs(n - ans) < 1e-9;
      };
      return q;
    }

    if (t === 'frac') {
      // add like 1/4 + 2/4 or simplify not required (accept equivalent)
      const den = [4, 5, 6, 8][randi(0, 4)];
      const a = randi(1, den - 1);
      const b = randi(1, den - 1);
      const num = a + b;
      q.text = `What is ${a}/${den} + ${b}/${den}? (Answer as a fraction or decimal)`;
      const exact = num / den;
      q.check = (s) => {
        const n = parseMaybeNumberOrFraction(s);
        return n !== null && Math.abs(n - exact) < 1e-9;
      };
      return q;
    }

    if (t === 'area') {
      const w = randi(4, 18);
      const h = randi(3, 14);
      const ans = w * h;
      q.text = `A rectangle is ${w} units wide and ${h} units tall. What is its area?`;
      q.check = (s) => parseMaybeNumberOrFraction(s) === ans;
      return q;
    }

    if (t === 'perim') {
      const w = randi(5, 22);
      const h = randi(4, 18);
      const ans = 2 * (w + h);
      q.text = `A rectangle is ${w} cm by ${h} cm. What is its perimeter (cm)?`;
      q.check = (s) => parseMaybeNumberOrFraction(s) === ans;
      return q;
    }

    // ops
    {
      const a = randi(2, 12), b = randi(2, 12), c = randi(5, 30);
      const ans = a * b + c;
      q.text = `What is ${a} √ó ${b} + ${c}?`;
      q.check = (s) => parseMaybeNumberOrFraction(s) === ans;
      return q;
    }
  }

  // ---------- Tag Logic ----------
  let lastPlayersOverlapping = false;

  function initiatorOfCollision(A, B) {
    // Determine initiator based on relative motion towards the other along separation axis.
    const acx = A.x + A.w/2, acy = A.y + A.h/2;
    const bcx = B.x + B.w/2, bcy = B.y + B.h/2;
    const sx = bcx - acx;
    const sy = bcy - acy;

    // Relative velocity A towards B is (A - B)
    const rvx = A.vx - B.vx;
    const rvy = A.vy - B.vy;

    // If dot(relVel, sep) > 0 then A moving towards B (in direction from A->B)
    const dot = rvx * sx + rvy * sy;

    // If dot is strongly positive -> A initiated.
    // If strongly negative -> B initiated.
    if (dot > 0) return A;
    if (dot < 0) return B;

    // fallback: who is moving faster overall
    const as = A.vx*A.vx + A.vy*A.vy;
    const bs = B.vx*B.vx + B.vy*B.vy;
    return as >= bs ? A : B;
  }

  function tryStartTagQuestion(initiator, other) {
    // Only if one is "it"
    const itPlayer = P1.isIt ? P1 : P2.isIt ? P2 : null;
    if (!itPlayer) return;

    // If initiator isn't "it", collision doesn't trigger a tag attempt
    if (initiator !== itPlayer) return;

    // Cooldown
    if (initiator.tagCooldown > 0) return;
    initiator.tagCooldown = 700;

    const q = makeQuestion();

    showQuestion({
      who: initiator,
      reason: 'Tag attempt',
      q: {
        text: q.text,
        check: q.check,
        onResolve: (correct) => {
          if (correct) {
            initiator.isIt = false;
            other.isIt = true;
          } else {
            // stays it
          }
        }
      }
    });
  }

  // ---------- Buff application ----------
  function applyBuff(player, type) {
    const enemy = (player === P1) ? P2 : P1;

    const tenSec = 10000;

    if (type === 'speed') player.speedBoost = tenSec;
    else if (type === 'jump') player.jumpBoost = tenSec;
    else if (type === 'both') { player.speedBoost = tenSec; player.jumpBoost = tenSec; }
    else if (type === 'swapIt') { enemy.isIt = true; player.isIt = false; }
    else if (type === 'invert') player.invert = tenSec;
    else if (type === 'teleport') {
      const spot = randomSafeSpot(player.w, player.h);
      player.x = spot.x; player.y = spot.y;
      player.vx = 0; player.vy = 0;
    }
    else if (type === 'slowEnemy') enemy.slow = tenSec;
  }

  function tryCollectBuff(player) {
    for (let i = 0; i < buffsOnMap.length; i++) {
      const b = buffsOnMap[i];
      if (!aabbOverlap(player, b)) continue;

      // Remove from map immediately
      buffsOnMap.splice(i, 1);

      const q = makeQuestion();
      showQuestion({
        who: player,
        reason: `Buff pickup: ${buffIcons[b.type]} ${b.label}`,
        q: {
          text: q.text,
          check: q.check,
          onResolve: (correct) => {
            if (correct) {
              applyBuff(player, b.type);
            } else {
              // no buff
            }
          }
        }
      });
      return;
    }
  }

  // ---------- Physics / Movement ----------
  function effectiveSpeed(p) {
    let s = base.speed;
    if (p.speedBoost > 0) s *= 1.65;
    if (p.slow > 0) s *= 0.60;
    return s;
  }

  function effectiveJump(p) {
    let j = base.jumpV;
    if (p.jumpBoost > 0) j *= 1.25;
    return j;
  }

  function updatePlayer(p, dt) {
    p.onGround = false;

    // timers
    p.speedBoost = Math.max(0, p.speedBoost - dt);
    p.jumpBoost = Math.max(0, p.jumpBoost - dt);
    p.invert = Math.max(0, p.invert - dt);
    p.slow = Math.max(0, p.slow - dt);
    p.tagCooldown = Math.max(0, p.tagCooldown - dt);

    const inv = (p.invert > 0) ? -1 : 1;

    // inputs
    const leftPressed = keys.has(p.controls.left);
    const rightPressed = keys.has(p.controls.right);
    const jumpPressed = keys.has(p.controls.jump);

    let move = 0;
    if (leftPressed) move -= 1;
    if (rightPressed) move += 1;
    move *= inv;

    // horizontal accel
    const targetVx = move * effectiveSpeed(p);
    // smooth
    const accel = 2200;
    p.vx += clamp(targetVx - p.vx, -accel*dt/1000, accel*dt/1000);

    if (move !== 0) p.facing = Math.sign(move);

    // jumping (edge triggered)
    if (!p._jumpHeld && jumpPressed) {
      if (p.jumpsLeft > 0) {
        p.vy = -effectiveJump(p);
        p.jumpsLeft -= 1;
      }
    }
    p._jumpHeld = jumpPressed;

    // gravity
    p.vy += base.gravity * (dt/1000);
    p.vy = Math.min(p.vy, base.maxFall);

    // integrate
    p.x += p.vx * (dt/1000);
    p.y += p.vy * (dt/1000);

    // bounds
    p.x = clamp(p.x, 0, W - p.w);

    // collisions with platforms
    for (const plat of platforms) {
      if (!aabbOverlap(p, plat)) continue;
      resolveAABB(p, plat);
    }

    // floor safety
    if (p.y > H - p.h - ground.h) {
      p.y = H - p.h - ground.h;
      p.vy = 0;
      p.onGround = true;
      p.jumpsLeft = 2;
    }

    // launch pads
    for (const lp of launchPads) {
      if (aabbOverlap(p, lp)) {
        // super jump, but avoid repeated triggers by requiring a small cooldown on vertical
        if (!p._launchCD || p._launchCD <= 0) {
          p.vy = -820;
          p._launchCD = 700;
        }
      }
    }
    p._launchCD = (p._launchCD || 0) - dt;
  }

  // ---------- Drawing (park background + nature platforms) ----------
  function drawBackground(t) {
    // sky gradient
    const g = ctx.createLinearGradient(0, 0, 0, H);
    g.addColorStop(0, '#78c8ff');
    g.addColorStop(0.45, '#bfeaff');
    g.addColorStop(1, '#1b5a34');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, W, H);

    // distant hills
    ctx.fillStyle = 'rgba(20,120,60,.35)';
    ctx.beginPath();
    ctx.moveTo(0, H*0.65);
    for (let x = 0; x <= W; x += 80) {
      ctx.quadraticCurveTo(x+40, H*0.56 + 12*Math.sin((t/900)+x/180), x+80, H*0.65);
    }
    ctx.lineTo(W, H);
    ctx.lineTo(0, H);
    ctx.closePath();
    ctx.fill();

    // trees
    function tree(x, y, s) {
      // trunk
      ctx.fillStyle = 'rgba(70,40,20,.75)';
      ctx.fillRect(x - 6*s, y, 12*s, 44*s);
      // leaves
      ctx.fillStyle = 'rgba(30,140,70,.85)';
      ctx.beginPath();
      ctx.arc(x, y, 22*s, 0, Math.PI*2);
      ctx.arc(x - 18*s, y + 8*s, 18*s, 0, Math.PI*2);
      ctx.arc(x + 18*s, y + 8*s, 18*s, 0, Math.PI*2);
      ctx.fill();
    }
    tree(90, 220, 1.0);
    tree(W-120, 240, 1.15);
    tree(220, 270, 0.9);
    tree(W-240, 280, 0.95);

    // ground grass
    ctx.fillStyle = 'rgba(25,120,55,.92)';
    ctx.fillRect(0, H - ground.h, W, ground.h);

    // subtle texture dots
    ctx.globalAlpha = 0.12;
    ctx.fillStyle = '#000';
    for (let i = 0; i < 300; i++) {
      const x = (i*37) % W;
      const y = H - ground.h + ((i*91) % ground.h);
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.globalAlpha = 1;
  }

  function drawPlatforms() {
    for (const p of platforms) {
      if (p === ground) continue;
      // platform body
      ctx.fillStyle = 'rgba(35,160,80,.95)';
      drawRoundedRect(p.x, p.y, p.w, p.h, 10);
      // top highlight
      ctx.fillStyle = 'rgba(255,255,255,.12)';
      drawRoundedRect(p.x, p.y, p.w, Math.max(6, p.h*0.35), 10);
      // little "moss" bumps
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = '#000';
      for (let i = 0; i < Math.floor(p.w/38); i++) {
        ctx.beginPath();
        ctx.arc(p.x + 20 + i*38, p.y + 4, 7, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    // ground top edge
    ctx.fillStyle = 'rgba(255,255,255,.10)';
    ctx.fillRect(0, H - ground.h, W, 5);
  }

  function drawLaunchPads() {
    for (const lp of launchPads) {
      ctx.fillStyle = 'rgba(255,255,255,.16)';
      drawRoundedRect(lp.x, lp.y, lp.w, lp.h, 10);

      ctx.fillStyle = 'rgba(255,255,255,.10)';
      drawRoundedRect(lp.x + 6, lp.y + 3, lp.w - 12, lp.h - 6, 10);

      ctx.fillStyle = 'rgba(255,255,255,.92)';
      ctx.font = '16px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('‚áß', lp.x + lp.w/2, lp.y + lp.h/2 + 1);
    }
  }

  function drawPlayer(p) {
    // shadow
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.ellipse(p.x + p.w/2, p.y + p.h + 6, 18, 6, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // body
    ctx.fillStyle = p.color;
    drawRoundedRect(p.x, p.y, p.w, p.h, 10);

    // face
    ctx.fillStyle = 'rgba(255,255,255,.88)';
    const eyeY = p.y + 16;
    const eyeX = p.x + (p.facing > 0 ? 22 : 12);
    ctx.beginPath();
    ctx.arc(eyeX, eyeY, 3, 0, Math.PI*2);
    ctx.fill();

    // outline "it"
    if (p.isIt) {
      ctx.strokeStyle = 'rgba(255,215,80,.95)';
      ctx.lineWidth = 4;
      ctx.strokeRect(p.x - 3, p.y - 3, p.w + 6, p.h + 6);
      ctx.lineWidth = 1;
    }

    // buff indicators
    const icons = [];
    if (p.speedBoost > 0) icons.push('‚ö°');
    if (p.jumpBoost > 0) icons.push('ü¶ò');
    if (p.invert > 0) icons.push('üîÅ');
    if (p.slow > 0) icons.push('üßä');

    if (icons.length) {
      ctx.font = '18px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.fillStyle = 'rgba(255,255,255,.95)';
      ctx.fillText(icons.join(' '), p.x + p.w/2, p.y - 6);
    }
  }

  function drawBuffs(t) {
    ctx.font = '18px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    for (const b of buffsOnMap) {
      b.bob += 0.06;
      const bobY = Math.sin(b.bob + t/500) * 4;

      // glow
      ctx.globalAlpha = 0.20;
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(b.x + b.w/2, b.y + b.h/2 + bobY, 18, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;

      // token
      ctx.fillStyle = 'rgba(0,0,0,.22)';
      drawRoundedRect(b.x, b.y + bobY, b.w, b.h, 8);

      ctx.fillStyle = 'rgba(255,255,255,.14)';
      drawRoundedRect(b.x+2, b.y+2 + bobY, b.w-4, b.h-4, 8);

      ctx.fillStyle = 'rgba(255,255,255,.95)';
      ctx.fillText(buffIcons[b.type] || '‚òÖ', b.x + b.w/2, b.y + b.h/2 + bobY + 1);
    }
  }

  function drawHUD() {
    const itName = P1.isIt ? 'Blue' : 'Red';
    const itDot = P1.isIt ? 'blue' : 'red';

    function fmt(ms) {
      const s = Math.ceil(ms/1000);
      return `${s}s`;
    }

    const pLine = (p) => {
      const bits = [];
      if (p.speedBoost > 0) bits.push(`‚ö° ${fmt(p.speedBoost)}`);
      if (p.jumpBoost > 0) bits.push(`ü¶ò ${fmt(p.jumpBoost)}`);
      if (p.invert > 0) bits.push(`üîÅ ${fmt(p.invert)}`);
      if (p.slow > 0) bits.push(`üßä ${fmt(p.slow)}`);
      return bits.length ? bits.join('  ‚Ä¢  ') : '‚Äî';
    };

    hudEl.innerHTML = `
      <div style="display:flex; gap:10px; align-items:center; margin-bottom:8px;">
        <span class="pill"><span class="dot ${itDot}"></span> IT: ${itName}</span>
        <span style="opacity:.85; font-weight:700;">Buffs spawn randomly</span>
      </div>
      <div style="display:grid; gap:6px;">
        <div><b style="color:rgba(90,190,255,.95);">Blue</b> ‚Äî ${pLine(P1)}</div>
        <div><b style="color:rgba(255,120,120,.95);">Red</b> ‚Äî ${pLine(P2)}</div>
      </div>
    `;
  }

  // ---------- Main Loop ----------
  let last = performance.now();

  function tick(now) {
    const dt = clamp(now - last, 0, 33);
    last = now;

    if (!pausedForQuestion) {
      updatePlayer(P1, dt);
      updatePlayer(P2, dt);

      // Spawn buffs every ~6‚Äì10 seconds, capped
      buffSpawnTimer -= dt;
      if (buffSpawnTimer <= 0 && buffsOnMap.length < 4) {
        spawnBuff();
        buffSpawnTimer = rand(6000, 10000);
      }

      // Collect buffs (triggers question)
      if (!pausedForQuestion) {
        tryCollectBuff(P1);
      }
      if (!pausedForQuestion) {
        tryCollectBuff(P2);
      }

      // Player-player collision tag check
      const overlapping = aabbOverlap(P1, P2);
      if (overlapping && !lastPlayersOverlapping) {
        // New collision start
        const initiator = initiatorOfCollision(P1, P2);
        const other = (initiator === P1) ? P2 : P1;

        // Keep them from sticking together
        // small push apart
        const push = 10;
        if (initiator.x < other.x) { initiator.x -= push; other.x += push; }
        else { initiator.x += push; other.x -= push; }

        // Tag question if initiator is IT
        if (!pausedForQuestion) {
          tryStartTagQuestion(initiator, other);
        }
      }
      lastPlayersOverlapping = overlapping;
    }

    // ---------- Render ----------
    drawBackground(now);
    drawPlatforms();
    drawLaunchPads();
    drawBuffs(now);
    drawPlayer(P1);
    drawPlayer(P2);
    drawHUD();

    requestAnimationFrame(tick);
  }

  // ---------- Start ----------
  buffSpawnTimer = rand(1500, 3500);
  requestAnimationFrame(tick);

})();
</script>
</body>
</html>
